/**
 * Accounting Library - Journal Entry Automation
 * Phase 1 Task 1.2 - Core functions for automated journal entry creation
 */

import { query, withTransaction } from '@/lib/db';
import { randomUUID } from 'crypto';
import type {
  CreateAutoJournalEntryRequest,
  CreateJournalEntryResponse,
  JournalEntryLine,
  JournalEntryValidation,
} from './types';
import { DEFAULT_ACCOUNT_MAPPING, type AccountMapping } from './types';

// Note: randomUUID is available in Node.js 14.17.0+ and is a named export in newer versions
// If using older Node.js, use: import crypto from 'crypto'; then crypto.randomUUID()

/**
 * Validates that a journal entry is balanced (debits = credits)
 *
 * @param lines - Array of journal entry lines
 * @returns Validation result with any errors
 */
export function validateJournalEntry(lines: JournalEntryLine[]): JournalEntryValidation {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check for empty lines
  if (!lines || lines.length === 0) {
    errors.push('Journal entry must have at least one line');
    return { valid: false, balanced: false, errors, warnings };
  }

  // Calculate totals
  const totalDebits = lines.reduce((sum, line) => sum + (line.debit || 0), 0);
  const totalCredits = lines.reduce((sum, line) => sum + (line.credit || 0), 0);

  // Check if balanced (allow for rounding errors within 0.01)
  const balanced = Math.abs(totalDebits - totalCredits) < 0.01;
  if (!balanced) {
    errors.push(`Journal entry not balanced: debits=${totalDebits}, credits=${totalCredits}`);
  }

  // Check for lines with both debit and credit
  lines.forEach((line, index) => {
    if (line.debit > 0 && line.credit > 0) {
      errors.push(`Line ${index + 1}: Cannot have both debit and credit`);
    }
    if (line.debit === 0 && line.credit === 0) {
      errors.push(`Line ${index + 1}: Must have either debit or credit`);
    }
    if (!line.accountCode) {
      errors.push(`Line ${index + 1}: Account code is required`);
    }
  });

  return {
    valid: errors.length === 0,
    balanced,
    errors,
    warnings,
  };
}

/**
 * Helper function to get account ID by account code
 * 
 * @param client - Database client (from transaction)
 * @param accountCode - Account code to look up
 * @returns Account ID (UUID) or null if not found
 */
async function getAccountIdByCode(client: any, accountCode: string): Promise<string | null> {
  const result = await client.query(
    'SELECT id FROM "Account" WHERE code = $1 AND "isActive" = true AND "isPosting" = true LIMIT 1',
    [accountCode]
  );
  
  if (result.rows.length === 0) {
    return null;
  }
  
  return result.rows[0].id;
}

/**
 * Creates an automated journal entry with source tracking
 *
 * This is the core function used by all automation workflows.
 * It validates the entry, creates the journal entry record, and creates all line items.
 *
 * @param request - Journal entry creation request
 * @returns Created journal entry with ID and balance info
 * @throws Error if validation fails or database operation fails
 */
export async function createAutoJournalEntry(
  request: CreateAutoJournalEntryRequest
): Promise<CreateJournalEntryResponse> {
  // Validate the entry
  const validation = validateJournalEntry(request.lines);
  if (!validation.valid) {
    throw new Error(`Invalid journal entry: ${validation.errors.join(', ')}`);
  }

  // Calculate totals for response
  const totalDebits = request.lines.reduce((sum, line) => sum + (line.debit || 0), 0);
  const totalCredits = request.lines.reduce((sum, line) => sum + (line.credit || 0), 0);

  return await withTransaction(async (client) => {
    try {
      // Generate unique ID for the journal entry
      const entryId = randomUUID();

      // Get the current open accounting period (or use null if not required)
      // For automated entries, we'll allow null periodId if no open period exists
      let periodId: string | null = null;
      try {
        const periodResult = await client.query(
          `SELECT id FROM "AccountingPeriod" 
           WHERE status = 'OPEN' 
           ORDER BY "startDate" DESC 
           LIMIT 1`
        );
        if (periodResult.rows.length > 0) {
          periodId = periodResult.rows[0].id;
        }
      } catch (error) {
        // If AccountingPeriod table doesn't exist or query fails, continue with null
        console.warn('Could not find open accounting period, continuing without periodId');
      }

      // Create the journal entry record
      const entryResult = await client.query(
        `INSERT INTO "JournalEntry" (
          id, "entryDate", description, status, 
          "sourceType", "sourceId", "autoGenerated",
          "periodId", "createdBy", "createdAt", "updatedAt"
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
        RETURNING id`,
        [
          entryId,
          request.date,
          request.description,
          'DRAFT', // Automated entries start as DRAFT
          request.sourceType,
          request.sourceId,
          true, // autoGenerated
          periodId,
          'SYSTEM', // Created by system for automated entries
        ]
      );

      const createdEntryId = entryResult.rows[0].id;

      // Validate and convert account codes to account IDs
      const accountCodeToIdMap = new Map<string, string>();
      
      for (const line of request.lines) {
        if (!accountCodeToIdMap.has(line.accountCode)) {
          const accountId = await getAccountIdByCode(client, line.accountCode);
          if (!accountId) {
            throw new Error(`Account with code '${line.accountCode}' not found or not active`);
          }
          accountCodeToIdMap.set(line.accountCode, accountId);
        }
      }

      // Create journal entry lines
      for (let i = 0; i < request.lines.length; i++) {
        const line = request.lines[i];
        const accountId = accountCodeToIdMap.get(line.accountCode)!;

        await client.query(
          `INSERT INTO "JournalEntryLine" (
            id, "entryId", "lineNumber", "accountId", 
            debit, credit, description, "createdAt"
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())`,
          [
            randomUUID(),
            createdEntryId,
            i + 1, // lineNumber starts at 1
            accountId,
            line.debit || 0,
            line.credit || 0,
            line.description || null,
          ]
        );
      }

      // Log successful creation
      console.log(`Created automated journal entry ${createdEntryId} for ${request.sourceType}:${request.sourceId}`);

      // Return the created entry with balance info
      return {
        id: createdEntryId,
        balanced: validation.balanced,
        totalDebits,
        totalCredits,
        lines: request.lines,
      };
    } catch (error: any) {
      console.error('Error creating automated journal entry:', error);
      throw new Error(`Failed to create journal entry: ${error.message}`);
    }
  });
}

/**
 * Checks if a journal entry already exists for a given source
 *
 * Prevents duplicate entries when automation runs multiple times
 *
 * @param sourceType - Type of source transaction
 * @param sourceId - ID of source transaction
 * @returns Journal entry ID if exists, null otherwise
 */
export async function findExistingJournalEntry(
  sourceType: string,
  sourceId: string
): Promise<string | null> {
  try {
    const result = await query(
      `SELECT id FROM "JournalEntry" 
       WHERE "sourceType" = $1 AND "sourceId" = $2 
       LIMIT 1`,
      [sourceType, sourceId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0].id;
  } catch (error: any) {
    console.error('Error finding existing journal entry:', error);
    throw new Error(`Failed to check for existing journal entry: ${error.message}`);
  }
}

/**
 * Gets account code from configuration or defaults
 *
 * In the future, this will support custom account mappings per company
 * For now, uses the default mapping from types.ts
 *
 * @param accountType - Type of account (e.g., 'revenueAccount', 'cogsAccount')
 * @returns Account code string
 * @throws Error if account type is invalid
 */
export function getAccountCode(accountType: keyof AccountMapping): string {
  const accountCode = DEFAULT_ACCOUNT_MAPPING[accountType];
  if (!accountCode) {
    throw new Error(`Invalid account type: ${accountType}. Valid types are: ${Object.keys(DEFAULT_ACCOUNT_MAPPING).join(', ')}`);
  }
  return accountCode;
}
