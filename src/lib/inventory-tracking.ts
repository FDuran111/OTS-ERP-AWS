import { Pool } from 'pg'

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
})

export interface InventoryLevel {
  id?: string
  materialId: string
  warehouseId: string
  currentStock: number
  reservedStock: number
  availableStock?: number
  reorderPoint: number
  reorderQuantity: number
  maxStockLevel?: number
  binLocation?: string
  zone?: string
  averageCost?: number
  lastPurchaseCost?: number
  totalValue?: number
  lastStockCount?: string
  lastStockMovement?: string
  createdAt?: string
  updatedAt?: string
}

export interface StockMovement {
  id?: string
  materialId: string
  warehouseId: string
  movementType: 'PURCHASE' | 'SALE' | 'TRANSFER' | 'ADJUSTMENT' | 'RETURN' | 'DAMAGED' | 'EXPIRED' | 'STOLEN' | 'FOUND' | 'INITIAL_STOCK' | 'PHYSICAL_COUNT'
  quantity: number
  previousStock: number
  newStock: number
  unitCost?: number
  totalCost?: number
  referenceType?: string
  referenceId?: string
  documentNumber?: string
  reason?: string
  notes?: string
  performedBy?: string
  createdAt?: string
}

export interface ReorderRequest {
  id?: string
  materialId: string
  warehouseId: string
  requestedQuantity: number
  currentStock: number
  reorderPoint: number
  urgencyLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  status: 'PENDING' | 'ORDERED' | 'RECEIVED' | 'CANCELLED'
  statusNotes?: string
  isAutoGenerated: boolean
  generatedAt?: string
  reviewedBy?: string
  reviewedAt?: string
  createdAt?: string
  updatedAt?: string
}

export interface StockAlert {
  id?: string
  materialId: string
  warehouseId: string
  alertType: string
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  title: string
  message: string
  currentStock?: number
  thresholdValue?: number
  recommendedAction?: string
  isActive: boolean
  isResolved: boolean
  resolvedBy?: string
  resolvedAt?: string
  resolutionNotes?: string
  createdAt?: string
  updatedAt?: string
}

export interface Warehouse {
  id?: string
  code: string
  name: string
  description?: string
  isMainWarehouse: boolean
  isActive: boolean
  address?: string
  city?: string
  state?: string
  zipCode?: string
  country?: string
  managerName?: string
  managerPhone?: string
  managerEmail?: string
  createdAt?: string
  updatedAt?: string
}

// Initialize inventory system with main warehouse setup
export async function initializeInventorySystem() {
  const client = await pool.connect()
  
  try {
    await client.query('BEGIN')
    
    // Create types if they don't exist
    await client.query(`
      DO $$ BEGIN
          CREATE TYPE stock_movement_type AS ENUM (
              'PURCHASE', 'SALE', 'TRANSFER', 'ADJUSTMENT', 'RETURN', 'DAMAGED', 
              'EXPIRED', 'STOLEN', 'FOUND', 'INITIAL_STOCK', 'PHYSICAL_COUNT'
          );
      EXCEPTION
          WHEN duplicate_object THEN null;
      END $$;
    `)
    
    await client.query(`
      DO $$ BEGIN
          CREATE TYPE reorder_status AS ENUM ('PENDING', 'ORDERED', 'RECEIVED', 'CANCELLED');
      EXCEPTION
          WHEN duplicate_object THEN null;
      END $$;
    `)
    
    await client.query(`
      DO $$ BEGIN
          CREATE TYPE alert_severity AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL');
      EXCEPTION
          WHEN duplicate_object THEN null;
      END $$;
    `)
    
    // Create inventory levels table
    await client.query(`
      CREATE TABLE IF NOT EXISTS "InventoryLevel" (
          id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
          "materialId" text NOT NULL REFERENCES "Material"(id) ON DELETE CASCADE,
          "warehouseId" uuid NOT NULL REFERENCES "Warehouse"(id) ON DELETE CASCADE,
          "currentStock" decimal(15, 4) NOT NULL DEFAULT 0,
          "reservedStock" decimal(15, 4) NOT NULL DEFAULT 0,
          "availableStock" decimal(15, 4) GENERATED ALWAYS AS ("currentStock" - "reservedStock") STORED,
          "reorderPoint" integer DEFAULT 10,
          "reorderQuantity" integer DEFAULT 50,
          "maxStockLevel" integer,
          "binLocation" varchar(50),
          "zone" varchar(50),
          "averageCost" decimal(15, 4),
          "lastPurchaseCost" decimal(15, 4),
          "totalValue" decimal(15, 2) GENERATED ALWAYS AS ("currentStock" * COALESCE("averageCost", 0)) STORED,
          "lastStockCount" timestamp,
          "lastStockMovement" timestamp,
          "createdAt" timestamp NOT NULL DEFAULT NOW(),
          "updatedAt" timestamp NOT NULL DEFAULT NOW(),
          UNIQUE("materialId", "warehouseId")
      );
    `)
    
    // Create stock movement table
    await client.query(`
      CREATE TABLE IF NOT EXISTS "StockMovement" (
          id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
          "materialId" text NOT NULL REFERENCES "Material"(id) ON DELETE CASCADE,
          "warehouseId" uuid NOT NULL REFERENCES "Warehouse"(id) ON DELETE CASCADE,
          "movementType" stock_movement_type NOT NULL,
          quantity decimal(15, 4) NOT NULL,
          "previousStock" decimal(15, 4) NOT NULL,
          "newStock" decimal(15, 4) NOT NULL,
          "unitCost" decimal(15, 4),
          "totalCost" decimal(15, 2),
          "referenceType" varchar(50),
          "referenceId" text,
          "documentNumber" varchar(100),
          reason text,
          notes text,
          "performedBy" text,
          "createdAt" timestamp NOT NULL DEFAULT NOW()
      );
    `)
    
    // Create reorder request table
    await client.query(`
      CREATE TABLE IF NOT EXISTS "ReorderRequest" (
          id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
          "materialId" text NOT NULL REFERENCES "Material"(id) ON DELETE CASCADE,
          "warehouseId" uuid NOT NULL REFERENCES "Warehouse"(id) ON DELETE CASCADE,
          "requestedQuantity" integer NOT NULL,
          "currentStock" decimal(15, 4) NOT NULL,
          "reorderPoint" integer NOT NULL,
          "urgencyLevel" alert_severity NOT NULL DEFAULT 'MEDIUM',
          status reorder_status NOT NULL DEFAULT 'PENDING',
          "statusNotes" text,
          "isAutoGenerated" boolean DEFAULT true,
          "generatedAt" timestamp DEFAULT NOW(),
          "reviewedBy" text,
          "reviewedAt" timestamp,
          "createdAt" timestamp NOT NULL DEFAULT NOW(),
          "updatedAt" timestamp NOT NULL DEFAULT NOW()
      );
    `)
    
    // Create stock alert table
    await client.query(`
      CREATE TABLE IF NOT EXISTS "StockAlert" (
          id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
          "materialId" text NOT NULL REFERENCES "Material"(id) ON DELETE CASCADE,
          "warehouseId" uuid NOT NULL REFERENCES "Warehouse"(id) ON DELETE CASCADE,
          "alertType" varchar(50) NOT NULL,
          severity alert_severity NOT NULL,
          title varchar(255) NOT NULL,
          message text NOT NULL,
          "currentStock" decimal(15, 4),
          "thresholdValue" decimal(15, 4),
          "recommendedAction" text,
          "isActive" boolean DEFAULT true,
          "isResolved" boolean DEFAULT false,
          "resolvedBy" text,
          "resolvedAt" timestamp,
          "resolutionNotes" text,
          "createdAt" timestamp NOT NULL DEFAULT NOW(),
          "updatedAt" timestamp NOT NULL DEFAULT NOW()
      );
    `)
    
    // Create indexes
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_inventory_level_material ON "InventoryLevel"("materialId");
      CREATE INDEX IF NOT EXISTS idx_inventory_level_warehouse ON "InventoryLevel"("warehouseId");
      CREATE INDEX IF NOT EXISTS idx_inventory_level_low_stock ON "InventoryLevel"("availableStock") WHERE "availableStock" <= "reorderPoint";
      CREATE INDEX IF NOT EXISTS idx_stock_movement_material ON "StockMovement"("materialId");
      CREATE INDEX IF NOT EXISTS idx_stock_movement_warehouse ON "StockMovement"("warehouseId");
      CREATE INDEX IF NOT EXISTS idx_stock_movement_date ON "StockMovement"("createdAt");
      CREATE INDEX IF NOT EXISTS idx_reorder_request_status ON "ReorderRequest"(status);
      CREATE INDEX IF NOT EXISTS idx_stock_alert_active ON "StockAlert"("isActive", "isResolved");
    `)
    
    await client.query('COMMIT')
    console.log('Inventory system initialized successfully')
    
  } catch (error) {
    await client.query('ROLLBACK')
    throw error
  } finally {
    client.release()
  }
}

// Get inventory levels with low stock alerts
export async function getInventoryLevels(warehouseId?: string): Promise<InventoryLevel[]> {
  let query = `
    SELECT il.*, m.name as "materialName", m.code as "materialCode", m.unit,
           w.name as "warehouseName", w.code as "warehouseCode"
    FROM "InventoryLevel" il
    JOIN "Material" m ON il."materialId" = m.id
    JOIN "Warehouse" w ON il."warehouseId" = w.id
    WHERE w."isActive" = true
  `
  
  const values: any[] = []
  
  if (warehouseId) {
    query += ` AND il."warehouseId" = $1`
    values.push(warehouseId)
  }
  
  query += ` ORDER BY il."availableStock" ASC, m.name ASC`
  
  const result = await pool.query(query, values)
  return result.rows
}

// Get materials with low stock
export async function getLowStockItems(warehouseId?: string): Promise<InventoryLevel[]> {
  let query = `
    SELECT il.*, m.name as "materialName", m.code as "materialCode", m.unit,
           w.name as "warehouseName", w.code as "warehouseCode"
    FROM "InventoryLevel" il
    JOIN "Material" m ON il."materialId" = m.id
    JOIN "Warehouse" w ON il."warehouseId" = w.id
    WHERE w."isActive" = true AND il."availableStock" <= il."reorderPoint"
  `
  
  const values: any[] = []
  
  if (warehouseId) {
    query += ` AND il."warehouseId" = $1`
    values.push(warehouseId)
  }
  
  query += ` ORDER BY il."availableStock" ASC`
  
  const result = await pool.query(query, values)
  return result.rows
}

// Create or update inventory level
export async function upsertInventoryLevel(inventoryLevel: InventoryLevel): Promise<InventoryLevel> {
  const query = `
    INSERT INTO "InventoryLevel" (
      "materialId", "warehouseId", "currentStock", "reservedStock",
      "reorderPoint", "reorderQuantity", "maxStockLevel", "binLocation", 
      "zone", "averageCost", "lastPurchaseCost"
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    ON CONFLICT ("materialId", "warehouseId") 
    DO UPDATE SET
      "currentStock" = EXCLUDED."currentStock",
      "reservedStock" = EXCLUDED."reservedStock",
      "reorderPoint" = EXCLUDED."reorderPoint",
      "reorderQuantity" = EXCLUDED."reorderQuantity",
      "maxStockLevel" = EXCLUDED."maxStockLevel",
      "binLocation" = EXCLUDED."binLocation",
      "zone" = EXCLUDED."zone",
      "averageCost" = EXCLUDED."averageCost",
      "lastPurchaseCost" = EXCLUDED."lastPurchaseCost",
      "updatedAt" = NOW()
    RETURNING *
  `
  
  const values = [
    inventoryLevel.materialId,
    inventoryLevel.warehouseId,
    inventoryLevel.currentStock,
    inventoryLevel.reservedStock,
    inventoryLevel.reorderPoint,
    inventoryLevel.reorderQuantity,
    inventoryLevel.maxStockLevel,
    inventoryLevel.binLocation,
    inventoryLevel.zone,
    inventoryLevel.averageCost,
    inventoryLevel.lastPurchaseCost
  ]
  
  const result = await pool.query(query, values)
  return result.rows[0]
}

// Record stock movement and update inventory levels
export async function recordStockMovement(movement: StockMovement): Promise<StockMovement> {
  const client = await pool.connect()
  
  try {
    await client.query('BEGIN')
    
    // Insert stock movement record
    const movementQuery = `
      INSERT INTO "StockMovement" (
        "materialId", "warehouseId", "movementType", quantity, "previousStock", 
        "newStock", "unitCost", "totalCost", "referenceType", "referenceId", 
        "documentNumber", reason, notes, "performedBy"
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      RETURNING *
    `
    
    const movementValues = [
      movement.materialId, movement.warehouseId, movement.movementType,
      movement.quantity, movement.previousStock, movement.newStock,
      movement.unitCost, movement.totalCost, movement.referenceType,
      movement.referenceId, movement.documentNumber, movement.reason,
      movement.notes, movement.performedBy
    ]
    
    const movementResult = await client.query(movementQuery, movementValues)
    
    // Update inventory level
    await client.query(`
      UPDATE "InventoryLevel"
      SET 
        "currentStock" = $1,
        "lastStockMovement" = NOW(),
        "averageCost" = CASE 
          WHEN $2 > 0 AND $3 IS NOT NULL THEN
            (("currentStock" * COALESCE("averageCost", 0)) + ($2 * $3)) / 
            NULLIF("currentStock" + $2, 0)
          ELSE "averageCost"
        END,
        "lastPurchaseCost" = CASE 
          WHEN $4 = 'PURCHASE' AND $3 IS NOT NULL THEN $3
          ELSE "lastPurchaseCost"
        END,
        "updatedAt" = NOW()
      WHERE "materialId" = $5 AND "warehouseId" = $6
    `, [
      movement.newStock, 
      movement.quantity, 
      movement.unitCost, 
      movement.movementType, 
      movement.materialId, 
      movement.warehouseId
    ])
    
    // Check for low stock and create alerts/reorder requests if needed
    await checkLowStockAlerts(client, movement.materialId, movement.warehouseId)
    
    await client.query('COMMIT')
    return movementResult.rows[0]
    
  } catch (error) {
    await client.query('ROLLBACK')
    throw error
  } finally {
    client.release()
  }
}

// Check and create low stock alerts/reorder requests
async function checkLowStockAlerts(client: any, materialId: string, warehouseId: string) {
  // Get current inventory level
  const levelResult = await client.query(`
    SELECT il.*, m.name as "materialName"
    FROM "InventoryLevel" il
    JOIN "Material" m ON il."materialId" = m.id
    WHERE il."materialId" = $1 AND il."warehouseId" = $2
  `, [materialId, warehouseId])
  
  if (levelResult.rows.length === 0) return
  
  const level = levelResult.rows[0]
  
  // Check if stock is below reorder point
  if (level.availableStock <= level.reorderPoint) {
    const alertType = level.availableStock <= 0 ? 'OUT_OF_STOCK' : 'LOW_STOCK'
    const severity = level.availableStock <= 0 ? 'CRITICAL' : 'HIGH'
    
    // Create stock alert if it doesn't exist
    await client.query(`
      INSERT INTO "StockAlert" (
        "materialId", "warehouseId", "alertType", severity, title, message,
        "currentStock", "thresholdValue", "recommendedAction"
      )
      SELECT $1, $2, $3, $4, $5, $6, $7, $8, $9
      WHERE NOT EXISTS (
        SELECT 1 FROM "StockAlert" 
        WHERE "materialId" = $1 AND "warehouseId" = $2 
        AND "alertType" IN ('LOW_STOCK', 'OUT_OF_STOCK')
        AND "isActive" = true AND "isResolved" = false
      )
    `, [
      materialId, warehouseId, alertType, severity,
      alertType === 'OUT_OF_STOCK' ? 'Out of Stock' : 'Low Stock Alert',
      `${level.materialName} is ${alertType === 'OUT_OF_STOCK' ? 'out of stock' : 'below reorder point'}`,
      level.availableStock, level.reorderPoint,
      'Review and create purchase order for this material'
    ])
    
    // Create reorder request if it doesn't exist
    await client.query(`
      INSERT INTO "ReorderRequest" (
        "materialId", "warehouseId", "requestedQuantity", "currentStock", 
        "reorderPoint", "urgencyLevel"
      )
      SELECT $1, $2, $3, $4, $5, $6
      WHERE NOT EXISTS (
        SELECT 1 FROM "ReorderRequest" 
        WHERE "materialId" = $1 AND "warehouseId" = $2 
        AND status IN ('PENDING', 'ORDERED')
      )
    `, [
      materialId, warehouseId, level.reorderQuantity, level.availableStock,
      level.reorderPoint, severity
    ])
  }
}

// Get active stock alerts
export async function getActiveStockAlerts(warehouseId?: string): Promise<StockAlert[]> {
  let query = `
    SELECT sa.*, m.name as "materialName", m.code as "materialCode",
           w.name as "warehouseName", w.code as "warehouseCode"
    FROM "StockAlert" sa
    JOIN "Material" m ON sa."materialId" = m.id
    JOIN "Warehouse" w ON sa."warehouseId" = w.id
    WHERE sa."isActive" = true AND sa."isResolved" = false
  `
  
  const values: any[] = []
  
  if (warehouseId) {
    query += ` AND sa."warehouseId" = $1`
    values.push(warehouseId)
  }
  
  query += ` ORDER BY sa.severity DESC, sa."createdAt" DESC`
  
  const result = await pool.query(query, values)
  return result.rows
}

// Get reorder requests
export async function getReorderRequests(status?: string): Promise<ReorderRequest[]> {
  let query = `
    SELECT rr.*, m.name as "materialName", m.code as "materialCode",
           w.name as "warehouseName", w.code as "warehouseCode"
    FROM "ReorderRequest" rr
    JOIN "Material" m ON rr."materialId" = m.id
    JOIN "Warehouse" w ON rr."warehouseId" = w.id
    WHERE 1=1
  `
  
  const values: any[] = []
  
  if (status) {
    query += ` AND rr.status = $1`
    values.push(status)
  }
  
  query += ` ORDER BY rr."urgencyLevel" DESC, rr."createdAt" DESC`
  
  const result = await pool.query(query, values)
  return result.rows
}

// Get inventory statistics
export async function getInventoryStats(warehouseId?: string) {
  let whereClause = 'WHERE w."isActive" = true'
  const values: any[] = []
  
  if (warehouseId) {
    whereClause += ' AND il."warehouseId" = $1'
    values.push(warehouseId)
  }
  
  const query = `
    SELECT 
      COUNT(il."materialId") as "totalMaterials",
      COUNT(il."materialId") FILTER (WHERE il."availableStock" > il."reorderPoint") as "wellStocked",
      COUNT(il."materialId") FILTER (WHERE il."availableStock" <= il."reorderPoint" AND il."availableStock" > 0) as "lowStock",
      COUNT(il."materialId") FILTER (WHERE il."availableStock" <= 0) as "outOfStock",
      COALESCE(SUM(il."totalValue"), 0) as "totalValue",
      COUNT(DISTINCT sa.id) FILTER (WHERE sa."isActive" = true AND sa."isResolved" = false) as "activeAlerts",
      COUNT(DISTINCT rr.id) FILTER (WHERE rr.status = 'PENDING') as "pendingReorders"
    FROM "InventoryLevel" il
    JOIN "Warehouse" w ON il."warehouseId" = w.id
    LEFT JOIN "StockAlert" sa ON il."materialId" = sa."materialId" AND il."warehouseId" = sa."warehouseId"
    LEFT JOIN "ReorderRequest" rr ON il."materialId" = rr."materialId" AND il."warehouseId" = rr."warehouseId"
    ${whereClause}
  `
  
  const result = await pool.query(query, values)
  return result.rows[0]
}

// Get warehouses
export async function getWarehouses(): Promise<Warehouse[]> {
  const query = `
    SELECT * FROM "Warehouse"
    WHERE "isActive" = true
    ORDER BY "isMainWarehouse" DESC, name ASC
  `
  
  const result = await pool.query(query)
  return result.rows
}