-- ================================================
-- Critical Database Triggers Migration
-- Exported from Replit Neon DB
-- Date: 2025-10-05
--
-- This migration adds essential database triggers that exist in the
-- Replit production database but are missing from the local database.
--
-- IMPORTANT: These triggers provide critical functionality:
-- 1. Auto-create JobLaborCost when time entries are approved
-- 2. Protect audit records from modification (immutability)
-- 3. Track role and permission changes for security
-- 4. Maintain material stock totals automatically
-- 5. Track material cost history
-- 6. Update accounting balances
--
-- DO NOT RUN THIS MIGRATION WITHOUT REVIEWING WITH THE TEAM
-- ================================================

-- ================================================
-- HELPER FUNCTIONS (Dependencies for triggers)
-- ================================================

-- Get the acting user ID from session or return 'SYSTEM'
CREATE OR REPLACE FUNCTION get_acting_user()
RETURNS TEXT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    acting_user_id TEXT;
BEGIN
    -- Try to get from session variable
    BEGIN
        acting_user_id := current_setting('app.current_user_id', true);
    EXCEPTION WHEN OTHERS THEN
        acting_user_id := NULL;
    END;

    -- If not set, return SYSTEM placeholder (never NULL)
    IF acting_user_id IS NULL OR acting_user_id = '' THEN
        RETURN 'SYSTEM';
    END IF;

    RETURN acting_user_id;
END;
$$;

-- Calculate total cost of a material kit
CREATE OR REPLACE FUNCTION calculate_kit_cost(kit_id VARCHAR)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
  total_cost DECIMAL(12,2);
BEGIN
  SELECT COALESCE(SUM(mki.quantity * m.cost), 0)
  INTO total_cost
  FROM "MaterialKitItem" mki
  JOIN "Material" m ON mki."materialId" = m.id
  WHERE mki."kitId" = kit_id;

  RETURN total_cost;
END;
$$;

-- Calculate total price of a material kit
CREATE OR REPLACE FUNCTION calculate_kit_price(kit_id VARCHAR)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
  total_price DECIMAL(12,2);
BEGIN
  SELECT COALESCE(SUM(mki.quantity * m.price), 0)
  INTO total_price
  FROM "MaterialKitItem" mki
  JOIN "Material" m ON mki."materialId" = m.id
  WHERE mki."kitId" = kit_id;

  RETURN total_price;
END;
$$;

-- ================================================
-- 1. AUDIT PROTECTION FUNCTIONS
-- ================================================

-- Prevent modification or deletion of audit records (immutability)
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  RAISE EXCEPTION 'Audit records are immutable and cannot be modified';
  RETURN NULL;
END;
$$;

-- ================================================
-- 2. TIME ENTRY APPROVAL AUTOMATION
-- ================================================

-- Auto-create JobLaborCost when time entry is approved
-- This is CRITICAL - the application code expects this to happen
CREATE OR REPLACE FUNCTION handle_approved_time_entry()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_labor_cost_id UUID;
BEGIN
  -- Only process if status changed to 'approved'
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
    -- Check if labor cost already exists for this time entry
    IF NOT EXISTS (
      SELECT 1 FROM "JobLaborCost" WHERE "timeEntryId" = NEW.id
    ) THEN
      -- Add labor cost from this time entry
      PERFORM add_labor_cost_from_time_entry(
        NEW."jobId",
        NEW."userId",
        NEW.hours::numeric,
        NEW.date::date,
        NEW.id
      );

      -- Get the ID of the created JobLaborCost
      SELECT id INTO v_labor_cost_id
      FROM "JobLaborCost"
      WHERE "timeEntryId" = NEW.id
      LIMIT 1;

      -- Log audit entry for automated JobLaborCost creation
      INSERT INTO "TimeEntryAudit" (
        id, entry_id, user_id, action,
        changed_by, changed_at,
        changes, notes,
        job_labor_cost_id
      ) VALUES (
        gen_random_uuid(),
        NEW.id,
        NEW."userId",
        'LABOR_COST_GENERATED',
        NEW."approvedBy",
        NOW(),
        jsonb_build_object(
          'laborCostId', v_labor_cost_id::text,
          'hours', NEW.hours,
          'autoGenerated', true
        ),
        'JobLaborCost automatically created by approval trigger',
        v_labor_cost_id
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- ================================================
-- 3. ROLE & PERMISSION AUDIT LOGGING
-- ================================================

-- Track all changes to roles (create, update, delete, activate/deactivate)
CREATE OR REPLACE FUNCTION log_role_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    acting_user_id TEXT;
    action_text TEXT;
    changes JSONB := '{}';
BEGIN
    acting_user_id := get_acting_user();

    IF TG_OP = 'INSERT' THEN
        INSERT INTO "UserAuditLog" (
            user_id, performed_by, action, resource, "resourceId",
            new_value, severity, metadata
        ) VALUES (
            NULL, acting_user_id, 'role_created', 'Role', NEW.id,
            NEW.name, 'INFO',
            jsonb_build_object('roleId', NEW.id, 'roleName', NEW.name, 'level', NEW.level)
        );

    ELSIF TG_OP = 'UPDATE' THEN
        -- Track name changes
        IF OLD.name IS DISTINCT FROM NEW.name THEN
            changes := changes || jsonb_build_object(
                'name', jsonb_build_object('old', OLD.name, 'new', NEW.name)
            );
        END IF;

        -- Track level changes
        IF OLD.level IS DISTINCT FROM NEW.level THEN
            changes := changes || jsonb_build_object(
                'level', jsonb_build_object('old', OLD.level, 'new', NEW.level)
            );
        END IF;

        -- Track isActive changes (critical for role lifecycle)
        IF OLD."isActive" IS DISTINCT FROM NEW."isActive" THEN
            changes := changes || jsonb_build_object(
                'isActive', jsonb_build_object('old', OLD."isActive", 'new', NEW."isActive")
            );
            action_text := CASE
                WHEN NEW."isActive" THEN 'role_activated'
                ELSE 'role_deactivated'
            END;
        END IF;

        -- Track isSystem changes
        IF OLD."isSystem" IS DISTINCT FROM NEW."isSystem" THEN
            changes := changes || jsonb_build_object(
                'isSystem', jsonb_build_object('old', OLD."isSystem", 'new', NEW."isSystem")
            );
        END IF;

        -- Only log if there were changes
        IF changes != '{}' THEN
            INSERT INTO "UserAuditLog" (
                user_id, performed_by, action, resource, "resourceId",
                old_value, new_value, severity, metadata
            ) VALUES (
                NULL, acting_user_id,
                COALESCE(action_text, 'role_modified'),
                'Role', NEW.id,
                changes::text, NULL,
                CASE WHEN action_text LIKE '%deactivated' THEN 'CRITICAL' ELSE 'WARNING' END,
                jsonb_build_object('roleId', NEW.id, 'roleName', NEW.name, 'changes', changes)
            );
        END IF;

    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO "UserAuditLog" (
            user_id, performed_by, action, resource, "resourceId",
            old_value, severity, metadata
        ) VALUES (
            NULL, acting_user_id, 'role_deleted', 'Role', OLD.id,
            OLD.name, 'CRITICAL',
            jsonb_build_object('roleId', OLD.id, 'roleName', OLD.name, 'level', OLD.level)
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$;

-- Track permission grant/revoke operations
CREATE OR REPLACE FUNCTION log_permission_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    acting_user_id TEXT;
BEGIN
    acting_user_id := get_acting_user();

    IF TG_OP = 'INSERT' THEN
        -- Prefer grantedBy over SYSTEM for new permissions
        IF acting_user_id = 'SYSTEM' AND NEW."grantedBy" IS NOT NULL THEN
            acting_user_id := NEW."grantedBy";
        END IF;

        INSERT INTO "UserAuditLog" (
            user_id, performed_by, action, resource, "resourceId", new_value, severity
        ) VALUES (
            NEW."userId", acting_user_id,
            CASE WHEN NEW.granted THEN 'permission_granted' ELSE 'permission_revoked' END,
            'UserPermission', NEW.id, NEW."permissionId", 'WARNING'
        );

    ELSIF TG_OP = 'UPDATE' AND OLD.granted IS DISTINCT FROM NEW.granted THEN
        -- Prefer grantedBy for updates
        IF acting_user_id = 'SYSTEM' AND NEW."grantedBy" IS NOT NULL THEN
            acting_user_id := NEW."grantedBy";
        END IF;

        INSERT INTO "UserAuditLog" (
            user_id, performed_by, action, resource, "resourceId",
            old_value, new_value, severity
        ) VALUES (
            NEW."userId", acting_user_id, 'permission_changed', 'UserPermission', NEW.id,
            OLD.granted::TEXT, NEW.granted::TEXT, 'WARNING'
        );

    ELSIF TG_OP = 'DELETE' THEN
        -- Use grantedBy from the deleted record if available
        IF acting_user_id = 'SYSTEM' AND OLD."grantedBy" IS NOT NULL THEN
            acting_user_id := OLD."grantedBy";
        END IF;

        INSERT INTO "UserAuditLog" (
            user_id, performed_by, action, resource, "resourceId", old_value, severity
        ) VALUES (
            OLD."userId", acting_user_id, 'permission_override_deleted', 'UserPermission', OLD.id,
            OLD."permissionId", 'WARNING'
        );
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$;

-- ================================================
-- 4. MATERIAL & INVENTORY MANAGEMENT
-- ================================================

-- Synchronize Material.inStock with sum of MaterialLocationStock quantities
CREATE OR REPLACE FUNCTION sync_material_total_stock()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_material_id TEXT;
BEGIN
  v_material_id := COALESCE(NEW."materialId", OLD."materialId");

  UPDATE "Material" m
  SET "inStock" = (
    SELECT COALESCE(SUM(mls.quantity), 0)
    FROM "MaterialLocationStock" mls
    WHERE mls."materialId" = v_material_id
  )
  WHERE m.id = v_material_id;

  RETURN NULL;
END;
$$;

-- Track material cost changes for historical analysis
CREATE OR REPLACE FUNCTION track_material_cost_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Only track if cost actually changed
  IF OLD.cost IS DISTINCT FROM NEW.cost THEN
    INSERT INTO "MaterialCostHistory" (
      id, "materialId", "previousCost", "newCost",
      source, "effectiveDate", "userId", "createdAt"
    ) VALUES (
      gen_random_uuid()::text,
      NEW.id,
      OLD.cost,
      NEW.cost,
      'MANUAL', -- Default source, can be overridden by application
      CURRENT_TIMESTAMP,
      NEW."updatedBy", -- Assumes Material table has updatedBy field
      CURRENT_TIMESTAMP
    );
  END IF;

  RETURN NEW;
END;
$$;

-- Update kit totals when kit items change
CREATE OR REPLACE FUNCTION update_kit_totals()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    UPDATE "MaterialKit"
    SET
      "unitCost" = calculate_kit_cost(OLD."kitId"),
      "unitPrice" = calculate_kit_price(OLD."kitId"),
      "updatedAt" = CURRENT_TIMESTAMP
    WHERE id = OLD."kitId";
    RETURN OLD;
  ELSE
    UPDATE "MaterialKit"
    SET
      "unitCost" = calculate_kit_cost(NEW."kitId"),
      "unitPrice" = calculate_kit_price(NEW."kitId"),
      "updatedAt" = CURRENT_TIMESTAMP
    WHERE id = NEW."kitId";
    RETURN NEW;
  END IF;
END;
$$;

-- ================================================
-- 5. ACCOUNTING & FINANCIAL
-- ================================================

-- Update account balances when journal entry lines are posted
CREATE OR REPLACE FUNCTION update_account_balance()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_account_id UUID;
  v_period_id UUID;
  v_debit_amount NUMERIC(15,2);
  v_credit_amount NUMERIC(15,2);
BEGIN
  -- Only update for POSTED entries
  SELECT "periodId" INTO v_period_id
  FROM "JournalEntry"
  WHERE id = NEW."entryId" AND status = 'POSTED';

  IF v_period_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Insert or update account balance
  INSERT INTO "AccountBalance" ("accountId", "periodId", "debitTotal", "creditTotal", "endingBalance")
  VALUES (
    NEW."accountId",
    v_period_id,
    NEW.debit,
    NEW.credit,
    NEW.debit - NEW.credit
  )
  ON CONFLICT ("accountId", "periodId") DO UPDATE SET
    "debitTotal" = "AccountBalance"."debitTotal" + NEW.debit,
    "creditTotal" = "AccountBalance"."creditTotal" + NEW.credit,
    "endingBalance" = "AccountBalance"."endingBalance" + (NEW.debit - NEW.credit),
    "lastUpdated" = NOW();

  RETURN NEW;
END;
$$;

-- ================================================
-- CREATE TRIGGERS
-- ================================================

-- Drop existing triggers if they exist (idempotent)
DROP TRIGGER IF EXISTS prevent_timeentryaudit_delete ON "TimeEntryAudit";
DROP TRIGGER IF EXISTS prevent_timeentryaudit_update ON "TimeEntryAudit";
DROP TRIGGER IF EXISTS trigger_approved_time_entry ON "TimeEntry";
DROP TRIGGER IF EXISTS trigger_log_role_changes_insert ON "Role";
DROP TRIGGER IF EXISTS trigger_log_role_changes_update ON "Role";
DROP TRIGGER IF EXISTS trigger_log_role_changes_delete ON "Role";
DROP TRIGGER IF EXISTS trigger_log_role_changes_user_update ON "User";
DROP TRIGGER IF EXISTS trigger_log_permission_change_insert ON "UserPermission";
DROP TRIGGER IF EXISTS trigger_log_permission_change_update ON "UserPermission";
DROP TRIGGER IF EXISTS trigger_log_permission_change_delete ON "UserPermission";
DROP TRIGGER IF EXISTS sync_material_stock_on_location_change_insert ON "MaterialLocationStock";
DROP TRIGGER IF EXISTS sync_material_stock_on_location_change_update ON "MaterialLocationStock";
DROP TRIGGER IF EXISTS sync_material_stock_on_location_change_delete ON "MaterialLocationStock";
DROP TRIGGER IF EXISTS trigger_track_material_cost ON "Material";
DROP TRIGGER IF EXISTS trigger_update_kit_totals_insert ON "MaterialKitItem";
DROP TRIGGER IF EXISTS trigger_update_kit_totals_update ON "MaterialKitItem";
DROP TRIGGER IF EXISTS trigger_update_kit_totals_delete ON "MaterialKitItem";
DROP TRIGGER IF EXISTS trigger_update_account_balance ON "JournalEntryLine";

-- 1. Audit Protection Triggers
CREATE TRIGGER prevent_timeentryaudit_delete
  BEFORE DELETE ON "TimeEntryAudit"
  FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

CREATE TRIGGER prevent_timeentryaudit_update
  BEFORE UPDATE ON "TimeEntryAudit"
  FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- 2. Time Entry Approval Automation (CRITICAL)
CREATE TRIGGER trigger_approved_time_entry
  AFTER INSERT OR UPDATE ON "TimeEntry"
  FOR EACH ROW EXECUTE FUNCTION handle_approved_time_entry();

-- 3. Role & Permission Audit Logging
CREATE TRIGGER trigger_log_role_changes_insert
  AFTER INSERT ON "Role"
  FOR EACH ROW EXECUTE FUNCTION log_role_changes();

CREATE TRIGGER trigger_log_role_changes_update
  AFTER UPDATE ON "Role"
  FOR EACH ROW EXECUTE FUNCTION log_role_changes();

CREATE TRIGGER trigger_log_role_changes_delete
  AFTER DELETE ON "Role"
  FOR EACH ROW EXECUTE FUNCTION log_role_changes();

CREATE TRIGGER trigger_log_role_changes_user_update
  AFTER UPDATE ON "User"
  FOR EACH ROW EXECUTE FUNCTION log_role_changes();

CREATE TRIGGER trigger_log_permission_change_insert
  AFTER INSERT ON "UserPermission"
  FOR EACH ROW EXECUTE FUNCTION log_permission_change();

CREATE TRIGGER trigger_log_permission_change_update
  AFTER UPDATE ON "UserPermission"
  FOR EACH ROW EXECUTE FUNCTION log_permission_change();

CREATE TRIGGER trigger_log_permission_change_delete
  AFTER DELETE ON "UserPermission"
  FOR EACH ROW EXECUTE FUNCTION log_permission_change();

-- 4. Material & Inventory Management
CREATE TRIGGER sync_material_stock_on_location_change_insert
  AFTER INSERT ON "MaterialLocationStock"
  FOR EACH ROW EXECUTE FUNCTION sync_material_total_stock();

CREATE TRIGGER sync_material_stock_on_location_change_update
  AFTER UPDATE ON "MaterialLocationStock"
  FOR EACH ROW EXECUTE FUNCTION sync_material_total_stock();

CREATE TRIGGER sync_material_stock_on_location_change_delete
  AFTER DELETE ON "MaterialLocationStock"
  FOR EACH ROW EXECUTE FUNCTION sync_material_total_stock();

CREATE TRIGGER trigger_track_material_cost
  AFTER UPDATE ON "Material"
  FOR EACH ROW EXECUTE FUNCTION track_material_cost_change();

CREATE TRIGGER trigger_update_kit_totals_insert
  AFTER INSERT ON "MaterialKitItem"
  FOR EACH ROW EXECUTE FUNCTION update_kit_totals();

CREATE TRIGGER trigger_update_kit_totals_update
  AFTER UPDATE ON "MaterialKitItem"
  FOR EACH ROW EXECUTE FUNCTION update_kit_totals();

CREATE TRIGGER trigger_update_kit_totals_delete
  AFTER DELETE ON "MaterialKitItem"
  FOR EACH ROW EXECUTE FUNCTION update_kit_totals();

-- 5. Accounting & Financial
CREATE TRIGGER trigger_update_account_balance
  AFTER INSERT ON "JournalEntryLine"
  FOR EACH ROW EXECUTE FUNCTION update_account_balance();

-- ================================================
-- VERIFICATION QUERIES
-- ================================================

-- Run these queries after migration to verify triggers were created:
--
-- SELECT trigger_name, event_object_table, event_manipulation
-- FROM information_schema.triggers
-- WHERE trigger_name LIKE '%approved_time_entry%'
--    OR trigger_name LIKE '%audit%'
--    OR trigger_name LIKE '%role%'
--    OR trigger_name LIKE '%permission%'
--    OR trigger_name LIKE '%material%'
--    OR trigger_name LIKE '%account%'
-- ORDER BY event_object_table, trigger_name;
