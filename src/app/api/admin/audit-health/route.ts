import { NextRequest, NextResponse } from 'next/server'
import { verifyToken } from '@/lib/auth'
import { query } from '@/lib/db'

export async function GET(request: NextRequest) {
  try {
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const userPayload = verifyToken(token)
    const userRole = userPayload.role

    if (!['ADMIN', 'OWNER_ADMIN'].includes(userRole)) {
      return NextResponse.json(
        { error: 'Insufficient permissions - Admin only' },
        { status: 403 }
      )
    }

    const totalAuditsResult = await query(
      `SELECT COUNT(*) as total FROM "TimeEntryAudit"`
    )
    const totalAudits = parseInt(totalAuditsResult.rows[0]?.total || '0')

    const recentAuditsResult = await query(
      `SELECT COUNT(*) as count 
       FROM "TimeEntryAudit" 
       WHERE changed_at >= NOW() - INTERVAL '24 hours'`
    )
    const last24Hours = parseInt(recentAuditsResult.rows[0]?.count || '0')

    const actionBreakdownResult = await query(
      `SELECT action, COUNT(*) as count 
       FROM "TimeEntryAudit" 
       WHERE changed_at >= NOW() - INTERVAL '7 days'
       GROUP BY action 
       ORDER BY count DESC`
    )
    const actionBreakdown = actionBreakdownResult.rows

    const entriesWithoutAuditResult = await query(
      `SELECT COUNT(*) as count 
       FROM "TimeEntry" te 
       WHERE te.status IN ('approved', 'REJECTED') 
       AND NOT EXISTS (
         SELECT 1 FROM "TimeEntryAudit" a 
         WHERE a.entry_id = te.id 
         AND a.action IN ('APPROVE', 'REJECT')
       )`
    )
    const entriesWithoutAudit = parseInt(entriesWithoutAuditResult.rows[0]?.count || '0')

    const bulkOperationsResult = await query(
      `SELECT correlation_id, COUNT(*) as entries, MIN(changed_at) as timestamp
       FROM "TimeEntryAudit"
       WHERE correlation_id IS NOT NULL
       AND changed_at >= NOW() - INTERVAL '7 days'
       GROUP BY correlation_id
       ORDER BY timestamp DESC
       LIMIT 10`
    )
    const recentBulkOperations = bulkOperationsResult.rows

    const laborCostAuditsResult = await query(
      `SELECT COUNT(*) as count
       FROM "TimeEntryAudit"
       WHERE action = 'LABOR_COST_GENERATED'
       AND changed_at >= NOW() - INTERVAL '7 days'`
    )
    const laborCostAudits = parseInt(laborCostAuditsResult.rows[0]?.count || '0')

    const linkedLaborCostsResult = await query(
      `SELECT COUNT(*) as count
       FROM "TimeEntryAudit"
       WHERE job_labor_cost_id IS NOT NULL
       AND changed_at >= NOW() - INTERVAL '7 days'`
    )
    const linkedLaborCosts = parseInt(linkedLaborCostsResult.rows[0]?.count || '0')

    const auditCoveragePercent = totalAudits > 0 
      ? ((totalAudits - entriesWithoutAudit) / totalAudits * 100).toFixed(2)
      : '100.00'

    const healthMetrics = {
      overall: {
        status: entriesWithoutAudit === 0 ? 'healthy' : 'warning',
        totalAudits,
        auditCoveragePercent,
        entriesWithoutAudit,
      },
      recent: {
        last24Hours,
        last7Days: actionBreakdown.reduce((sum, item) => sum + parseInt(item.count), 0),
      },
      actions: {
        breakdown: actionBreakdown,
      },
      bulkOperations: {
        count: recentBulkOperations.length,
        recent: recentBulkOperations,
      },
      laborCosts: {
        autoGenerated: laborCostAudits,
        linkedToAudits: linkedLaborCosts,
      },
      alerts: [] as Array<{ level: string; message: string; action: string }>
    }

    if (entriesWithoutAudit > 0) {
      healthMetrics.alerts.push({
        level: 'warning',
        message: `${entriesWithoutAudit} approved/rejected entries found without audit trail`,
        action: 'Review audit logging in approval/rejection APIs',
      })
    }

    if (last24Hours === 0) {
      healthMetrics.alerts.push({
        level: 'info',
        message: 'No audit entries in the last 24 hours',
        action: 'Normal if no time entry activity',
      })
    }

    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      metrics: healthMetrics,
    })
  } catch (error: any) {
    console.error('Error fetching audit health:', error)
    return NextResponse.json(
      { error: error.message || 'Failed to fetch audit health metrics' },
      { status: 500 }
    )
  }
}
