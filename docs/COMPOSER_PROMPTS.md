# Cursor Composer Prompts - Phase 1 Accounting Integration

**Purpose**: This document contains ready-to-use prompts for Cursor Composer to implement Phase 1 of the ERP improvement roadmap. Each prompt references actual files that have been created as templates/starters.

**Workflow**:
1. Copy the prompt for the current task
2. Paste into Cursor Composer
3. Composer will implement using the reference files
4. After completion, Claude will audit the changes
5. Claude will execute database migrations

---

## Task 1.1: Database Migrations (READY TO EXECUTE)

### ðŸ“‹ Prompt for Composer

```
Complete the database migrations for journal entry source tracking (Phase 1 Task 1.1).

Reference files (already created):
- migrations/phase1/001_add_journal_entry_source.sql
- migrations/phase1/001_add_journal_entry_source_rollback.sql

Your tasks:
1. Review the migration files to ensure they are correct
2. Verify the migration SQL is compatible with PostgreSQL
3. Ensure all indexes are properly defined
4. Verify the CHECK constraint includes all required source types

The migrations add:
- sourceType column (varchar 50) with CHECK constraint
- sourceId column (text) for linking to source records
- autoGenerated column (boolean) to identify automated entries
- Indexes for efficient lookups by source
- Comments for documentation

Do NOT execute the migrations - Claude will handle that.
Just verify the SQL is correct and ready to run.
```

**Expected Output**: Confirmation that migration files are ready, or corrections if needed

**Claude's Next Step**: Execute the migrations to the database using Bash tool

---

## Task 1.2: Journal Entry Automation Library (READY FOR IMPLEMENTATION)

### ðŸ“‹ Prompt for Composer

```
Implement the core journal entry automation library (Phase 1 Task 1.2).

Reference files (templates created):
- src/lib/accounting/types.ts (complete type definitions)
- src/lib/accounting/journal-entry-automation.ts (function stubs)

Your tasks:
1. Complete the implementation of journal-entry-automation.ts:

   a) createAutoJournalEntry function:
      - Use withTransaction from @/lib/db for atomicity
      - Generate unique ID using crypto.randomUUID()
      - Insert into JournalEntry table with source tracking fields
      - Insert all lines into JournalEntryLine table
      - Return CreateJournalEntryResponse with balance info

   b) findExistingJournalEntry function:
      - Query JournalEntry table for matching sourceType and sourceId
      - Return journal entry ID if found, null otherwise

   c) getAccountCode function:
      - Import DEFAULT_ACCOUNT_MAPPING from types.ts
      - Return the account code for the given account type
      - Add type safety to ensure valid account types

2. Database schema reference (existing tables):
   - JournalEntry: id (text), date, description, reference, sourceType, sourceId, autoGenerated, createdAt, updatedAt, createdBy
   - JournalEntryLine: id (text), journalEntryId, accountCode, debit, credit, description, departmentId, projectId

3. Error handling:
   - Throw descriptive errors for validation failures
   - Ensure transaction rollback on any error
   - Log important operations for debugging

4. Use the existing query() and withTransaction() functions from @/lib/db
```

**Expected Output**: Fully implemented journal-entry-automation.ts with working CRUD operations

**Testing**: Claude will run unit tests to verify

---

## Task 1.3: Invoice Revenue Recognition (READY FOR IMPLEMENTATION)

### ðŸ“‹ Prompt for Composer

```
Implement the invoice to revenue recognition automation (Phase 1 Task 1.3).

Reference file (template created):
- src/lib/workflows/invoice-automation.ts

Your tasks:
1. Complete the generateInvoiceJournalEntry function:

   a) Check for existing entry:
      const existingEntryId = await findExistingJournalEntry('INVOICE', invoiceId);
      if (existingEntryId) return existingEntryId;

   b) Fetch invoice data:
      - Query the Invoice table for the invoice
      - Get: id, customerId, amount, date, description
      - Throw error if invoice not found

   c) Get account codes:
      const arAccount = getAccountCode('accountsReceivableAccount'); // 1100
      const revenueAccount = getAccountCode('revenueAccount'); // 4000

   d) Create journal entry lines:
      const lines = [
        {
          accountCode: arAccount,
          debit: invoice.amount,
          credit: 0,
          description: `AR - Invoice ${invoice.id}`
        },
        {
          accountCode: revenueAccount,
          debit: 0,
          credit: invoice.amount,
          description: `Revenue - Invoice ${invoice.id}`
        }
      ];

   e) Create the journal entry:
      const entry = await createAutoJournalEntry({
        sourceType: 'INVOICE',
        sourceId: invoiceId,
        date: invoice.date,
        description: `Revenue recognition for invoice ${invoice.id}`,
        lines,
        reference: `INV-${invoice.id}`
      });

   f) Return the journal entry ID

2. Update the onInvoiceCreated handler to add proper error handling

3. Invoice table schema reference:
   - Invoice: id (text), customerId (text), amount (decimal), date (timestamp), description (text), status (varchar)
```

**Expected Output**: Working invoice automation that creates proper journal entries

**Testing**: Claude will create test invoices and verify journal entries are created correctly

---

## Task 1.4: Job Completion COGS Recognition (READY FOR IMPLEMENTATION)

### ðŸ“‹ Prompt for Composer

```
Implement the job completion to COGS recognition automation (Phase 1 Task 1.4).

Reference file (template created):
- src/lib/workflows/job-completion-automation.ts

Your tasks:
1. Complete the generateJobCompletionJournalEntry function:

   a) Check for existing entry:
      const existingEntryId = await findExistingJournalEntry('JOB_COMPLETION', jobId);
      if (existingEntryId) return existingEntryId;

   b) Fetch job cost data:
      - Query JobLaborCost for total labor cost
      - Query JobMaterialCost for total material cost
      - Query JobEquipmentCost for total equipment cost
      - Get job details (id, status, completionDate)
      - Throw error if job not found or not completed

   c) Calculate total costs:
      const laborCost = laborCostResult.rows[0]?.totalCost || 0;
      const materialCost = materialCostResult.rows[0]?.totalCost || 0;
      const equipmentCost = equipmentCostResult.rows[0]?.totalCost || 0;
      const totalCost = laborCost + materialCost + equipmentCost;

   d) Get account codes:
      const laborExpenseAccount = getAccountCode('laborExpenseAccount'); // 5100
      const materialExpenseAccount = getAccountCode('cogsAccount'); // 5000
      const equipmentExpenseAccount = getAccountCode('equipmentExpenseAccount'); // 5200
      const inventoryAccount = getAccountCode('inventoryAccount'); // 1200

   e) Create journal entry lines (only include non-zero amounts):
      const lines = [];
      if (laborCost > 0) {
        lines.push({
          accountCode: laborExpenseAccount,
          debit: laborCost,
          credit: 0,
          description: `Labor cost - Job ${jobId}`
        });
      }
      // ... repeat for materials and equipment

      // Credit side (total)
      lines.push({
        accountCode: inventoryAccount,
        debit: 0,
        credit: totalCost,
        description: `WIP/Inventory - Job ${jobId}`
      });

   f) Create the journal entry with proper error handling

2. Job cost table schema reference:
   - JobLaborCost: jobId, totalCost (calculated sum of time entries)
   - JobMaterialCost: jobId, totalCost (calculated sum of material usage)
   - JobEquipmentCost: jobId, totalCost (calculated sum of equipment usage)
```

**Expected Output**: Working job completion automation that creates COGS entries

**Testing**: Claude will verify against completed jobs with costs

---

## Task 1.5: Unit Tests (READY FOR IMPLEMENTATION)

### ðŸ“‹ Prompt for Composer

```
Implement comprehensive unit tests for the accounting automation (Phase 1 Task 1.5).

Reference file (test template created):
- src/__tests__/accounting/journal-entry-automation.test.ts

Your tasks:
1. Implement all the skipped tests in the test file:
   - createAutoJournalEntry tests (database integration)
   - findExistingJournalEntry tests
   - Invoice automation tests
   - Job completion automation tests

2. Test setup requirements:
   - Create test database fixtures
   - Use proper setup/teardown with beforeAll/afterAll
   - Clean up test data after each test
   - Use transactions for test isolation if possible

3. What to test:
   a) Happy path scenarios (successful creation)
   b) Error scenarios (invalid data, missing records)
   c) Duplicate prevention (same source shouldn't create multiple entries)
   d) Transaction rollback on failures
   e) Balance validation (debits = credits)
   f) Account code validation

4. Testing patterns:
   - Use descriptive test names
   - Assert both database state and return values
   - Test edge cases (zero amounts, missing optional fields)
   - Verify source tracking fields are set correctly

5. Run tests with: npm test -- journal-entry-automation.test.ts
```

**Expected Output**: All tests passing with good coverage

**Testing**: Claude will review test results and coverage

---

## Task 2.1: Vendor Invoice Table (READY TO EXECUTE)

### ðŸ“‹ Prompt for Composer

```
Verify the vendor invoice table migration (Phase 1 Task 2.1).

Reference files (already created):
- migrations/phase1/002_add_vendor_invoice_table.sql
- migrations/phase1/002_add_vendor_invoice_table_rollback.sql

Your tasks:
1. Review the VendorInvoice table schema:
   - All required fields are present
   - Constraints are properly defined (status, amounts)
   - Indexes are optimized for queries
   - Foreign key comments are noted (to be added after verification)

2. Verify the migration includes:
   - Unique constraint on (vendorId, invoiceNumber)
   - Status CHECK constraint
   - Amount validation constraints
   - Proper indexes for lookups

3. Check that Vendor and PurchaseOrder tables exist:
   - If they exist, uncomment the foreign key constraints
   - If they don't exist, leave as comments for now

Do NOT execute the migrations - Claude will handle that.
```

**Expected Output**: Confirmed migration ready or adjustments made

**Claude's Next Step**: Execute migration to database

---

## Task 2.2: PO Receipt to AP Workflow (READY FOR IMPLEMENTATION)

### ðŸ“‹ Prompt for Composer

```
Implement the purchase order receipt to accounts payable automation (Phase 1 Task 2.2).

Reference file (template created):
- src/lib/workflows/po-receipt-automation.ts

Your tasks:
1. Complete the generatePOReceiptJournalEntry function:

   a) Check for existing entry for this PO

   b) Fetch PO data:
      - Query PurchaseOrder table
      - Get: id, vendorId, total, items, status, receiptDate
      - Verify status is 'RECEIVED'
      - Throw error if not found or not received

   c) Create journal entry lines:
      - DR Inventory (1200) for the PO total
      - CR Accounts Payable (2000) for the PO total

   d) Create the journal entry

   e) Create VendorInvoice record:
      - Link to the purchase order
      - Link to the journal entry
      - Set status to 'PENDING'
      - Use PO data for amounts and dates

   f) Return journal entry ID

2. VendorInvoice record structure:
   {
     id: crypto.randomUUID(),
     vendorId: po.vendorId,
     purchaseOrderId: po.id,
     invoiceNumber: `PO-${po.id}`,
     invoiceDate: po.receiptDate,
     dueDate: calculateDueDate(po.receiptDate, 30), // 30 days default
     amount: po.total,
     paidAmount: 0,
     status: 'PENDING',
     journalEntryId: entry.id,
     createdBy: 'SYSTEM'
   }

3. PurchaseOrder table schema reference:
   - PurchaseOrder: id, vendorId, total, status, createdAt, etc.
```

**Expected Output**: Working PO to AP automation

**Testing**: Claude will verify with test purchase orders

---

## Task 2.3: Payroll Accrual Automation (READY FOR IMPLEMENTATION)

### ðŸ“‹ Prompt for Composer

```
Implement the time approval to payroll accrual automation (Phase 1 Task 2.3).

Reference file (template created):
- src/lib/workflows/payroll-accrual-automation.ts

Your tasks:
1. Complete the generatePayrollAccrualJournalEntry function:

   a) Check for existing entries for these time entries

   b) Fetch time entry data:
      - Query TimeEntry table for all IDs in the array
      - Get: id, employeeId, regularHours, overtimeHours, doubleTimeHours, regularRate, overtimeRate, doubleTimeRate
      - Calculate total pay for each entry

   c) Calculate total payroll:
      let totalPayroll = 0;
      for (const entry of timeEntries) {
        const regularPay = (entry.regularHours || 0) * (entry.regularRate || 0);
        const overtimePay = (entry.overtimeHours || 0) * (entry.overtimeRate || 0);
        const doubleTimePay = (entry.doubleTimeHours || 0) * (entry.doubleTimeRate || 0);
        totalPayroll += regularPay + overtimePay + doubleTimePay;
      }

   d) Create journal entry lines:
      - DR Labor Expense (5100) for total payroll
      - CR Wages Payable (2100) for total payroll

   e) Create the journal entry with source tracking:
      - sourceType: 'TIME_APPROVAL'
      - sourceId: JSON.stringify(timeEntryIds) // Store array as JSON
      - description: Include number of entries and date range

   f) Return journal entry ID

2. TimeEntry table schema reference:
   - TimeEntry: id, employeeId, date, regularHours, overtimeHours, doubleTimeHours, regularRate, overtimeRate, doubleTimeRate, approved

3. Only process approved time entries (approved = true)
```

**Expected Output**: Working payroll accrual automation

**Testing**: Claude will verify with approved time entries

---

## Migration Execution Order

After Composer completes the verification/implementation, Claude will execute migrations in this order:

1. `001_add_journal_entry_source.sql` - Add source tracking to JournalEntry
2. `002_add_vendor_invoice_table.sql` - Create VendorInvoice table

**Rollback order** (if needed): Reverse order (002 rollback first, then 001)

---

## Testing Checklist (After All Tasks Complete)

Claude will verify:
- [ ] All migrations executed successfully
- [ ] Unit tests passing (Task 1.5)
- [ ] Invoice automation creates correct journal entries
- [ ] Job completion automation creates COGS entries
- [ ] PO receipt creates AP entries and VendorInvoice records
- [ ] Payroll accrual creates correct expense entries
- [ ] All entries have proper source tracking
- [ ] All journal entries are balanced
- [ ] No duplicate entries for same source
- [ ] Database constraints working (status, amounts, etc.)

---

## Next Steps After Phase 1

After Claude audits and confirms Phase 1 is complete:
1. Update production database with migrations
2. Deploy code to Render
3. Monitor for any issues
4. Begin Phase 2 planning (Real-Time Costing & Materials)
