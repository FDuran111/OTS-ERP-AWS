# Phase 1 Implementation Guide
# Accounting Integration - Detailed Task Specifications

**Generated:** 2025-11-07
**Purpose:** Step-by-step implementation guide for Phase 1 accounting automation
**Timeline:** 2 weeks
**Development Tool:** Cursor Composer
**Audit:** Claude Code after each task

---

## üöÄ Quick Start

### Pre-Flight Checklist

Before starting Task 1.1, ensure:

- [ ] **Database backup created**
  ```bash
  pg_dump $DATABASE_URL > backup_phase1_$(date +%Y%m%d).sql
  ```

- [ ] **Staging environment ready**
  - Supabase staging project OR local PostgreSQL
  - Copy of production data (sanitized)
  - Environment variables configured

- [ ] **Chart of Accounts documented**
  - List all account codes (1000, 1100, 4000, etc.)
  - Map to account names (Cash, AR, Revenue, etc.)
  - Confirm with accounting team

- [ ] **Development environment**
  - Cursor installed with Composer
  - Node.js 18+ and npm
  - PostgreSQL client (psql)
  - Git repository up to date

- [ ] **Communication channels**
  - How to share code with Claude for audit
  - How to report issues
  - Daily standup time (if applicable)

---

## üìã Implementation Workflow

**For Each Task:**

1. **Read Task Specification** (this document)
2. **Run Pre-Task Checklist**
3. **Use Cursor Composer** with provided prompts
4. **Self-Test** using provided test cases
5. **Share Code with Claude** for audit
6. **Fix Issues** if Claude finds any
7. **Mark Task Complete** and move to next

**Daily Rhythm:**
- Morning: Pick next task
- Work: Implement with Composer
- Afternoon: Audit with Claude
- Evening: Test on staging
- Repeat

---

## Task 1.1: Database Migrations - Journal Entry Source Tracking

### üéØ Goal

Add tracking fields to `JournalEntry` table to link journal entries to their source transactions (invoices, jobs, POs, etc.)

### üìÅ Files to Create

1. `migrations/phase1/001_add_journal_entry_source.sql`
2. `migrations/phase1/001_add_journal_entry_source_rollback.sql`

### üìù Detailed Specifications

**Add these columns to `JournalEntry` table:**

| Column | Type | Nullable | Default | Purpose |
|--------|------|----------|---------|---------|
| `sourceType` | varchar(50) | YES | NULL | Type of source (INVOICE, JOB_COMPLETION, etc.) |
| `sourceId` | text | YES | NULL | ID of the source record |
| `autoGenerated` | boolean | NO | false | True if auto-created by system |
| `reversedEntryId` | text | YES | NULL | Points to JE that reverses this one |

**Add constraints:**
```sql
ALTER TABLE "JournalEntry"
ADD CONSTRAINT "JournalEntry_sourceType_check"
CHECK ("sourceType" IS NULL OR "sourceType" IN (
  'INVOICE',
  'JOB_COMPLETION',
  'PURCHASE_ORDER',
  'PAYROLL_PERIOD',
  'PAYMENT',
  'ADJUSTMENT',
  'OPENING_BALANCE'
));
```

**Add indexes:**
```sql
CREATE INDEX idx_journal_entry_source
  ON "JournalEntry"("sourceType", "sourceId");

CREATE INDEX idx_journal_entry_auto_generated
  ON "JournalEntry"("autoGenerated")
  WHERE "autoGenerated" = true;
```

**Add comments:**
```sql
COMMENT ON COLUMN "JournalEntry"."sourceType" IS 'Type of transaction that generated this entry';
COMMENT ON COLUMN "JournalEntry"."sourceId" IS 'ID of the source transaction';
COMMENT ON COLUMN "JournalEntry"."autoGenerated" IS 'True if entry was automatically created by system';
```

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 1.1: Add source tracking to JournalEntry table

Requirements:
1. Create file: migrations/phase1/001_add_journal_entry_source.sql
2. Add columns: sourceType (varchar 50), sourceId (text), autoGenerated (boolean default false), reversedEntryId (text nullable)
3. Add CHECK constraint on sourceType with these allowed values: INVOICE, JOB_COMPLETION, PURCHASE_ORDER, PAYROLL_PERIOD, PAYMENT, ADJUSTMENT, OPENING_BALANCE
4. Create index on (sourceType, sourceId)
5. Create partial index on autoGenerated WHERE autoGenerated = true
6. Add column comments as specified
7. Wrap in BEGIN/COMMIT transaction
8. Add verification query at end to confirm columns exist

Also create rollback file: migrations/phase1/001_add_journal_entry_source_rollback.sql
- Drops indexes first
- Removes constraint
- Drops columns
- Wrapped in BEGIN/COMMIT

Use PostgreSQL syntax. Include helpful comments in SQL.
```

### ‚úÖ Testing Instructions

**After running migration on staging:**

```sql
-- 1. Verify columns exist
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'JournalEntry'
AND column_name IN ('sourceType', 'sourceId', 'autoGenerated', 'reversedEntryId');

-- Should return 4 rows

-- 2. Verify constraint exists
SELECT constraint_name, check_clause
FROM information_schema.check_constraints
WHERE constraint_name = 'JournalEntry_sourceType_check';

-- Should return 1 row

-- 3. Verify indexes exist
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'JournalEntry'
AND indexname IN ('idx_journal_entry_source', 'idx_journal_entry_auto_generated');

-- Should return 2 rows

-- 4. Test constraint works
BEGIN;
INSERT INTO "JournalEntry" (
  id, date, description, status, "sourceType"
) VALUES (
  'test-entry-1', CURRENT_DATE, 'Test entry', 'DRAFT', 'INVOICE'
);
-- Should succeed

INSERT INTO "JournalEntry" (
  id, date, description, status, "sourceType"
) VALUES (
  'test-entry-2', CURRENT_DATE, 'Test entry 2', 'DRAFT', 'INVALID_TYPE'
);
-- Should FAIL with constraint violation

ROLLBACK;
```

### üìã Audit Checklist

When sharing code with Claude, verify:

- [ ] Migration file uses BEGIN/COMMIT
- [ ] All 4 columns added with correct types
- [ ] CHECK constraint includes all 7 source types
- [ ] Both indexes created with correct syntax
- [ ] Comments added to all new columns
- [ ] Rollback script reverses all changes in correct order
- [ ] No syntax errors
- [ ] Transaction safety maintained

### ‚è±Ô∏è Estimated Time

- Implementation: 20 minutes
- Testing: 10 minutes
- **Total: 30 minutes**

---

## Task 1.2: Journal Entry Automation Library

### üéØ Goal

Create reusable library for generating journal entries from transactions automatically.

### üìÅ Files to Create

1. `src/lib/accounting/journal-entry-automation.ts`
2. `src/lib/accounting/types.ts`
3. `src/lib/accounting/account-mapping.ts`

### üìù Detailed Specifications

**Library Structure:**

```typescript
// src/lib/accounting/types.ts
export type SourceType =
  | 'INVOICE'
  | 'JOB_COMPLETION'
  | 'PURCHASE_ORDER'
  | 'PAYROLL_PERIOD'
  | 'PAYMENT'
  | 'ADJUSTMENT'
  | 'OPENING_BALANCE'

export interface JournalEntryLine {
  accountCode: string
  accountId: string
  debit: number
  credit: number
  description?: string
}

export interface AutoJournalEntryParams {
  sourceType: SourceType
  sourceId: string
  date: Date
  description: string
  lines: JournalEntryLine[]
}

// src/lib/accounting/account-mapping.ts
// Map account codes to account IDs (gets from DB)
export async function getAccountByCode(code: string): Promise<string | null>
export async function getAccountsByType(type: string): Promise<Account[]>

// src/lib/accounting/journal-entry-automation.ts
export async function createAutoJournalEntry(
  params: AutoJournalEntryParams
): Promise<{ journalEntryId: string; balanced: boolean }>

export async function reverseJournalEntry(
  journalEntryId: string,
  reason: string
): Promise<string>

export function validateJournalEntry(
  lines: JournalEntryLine[]
): { valid: boolean; errors: string[] }
```

**Key Functions:**

1. **createAutoJournalEntry:**
   - Validates lines balance (debits = credits)
   - Creates JournalEntry record with source tracking
   - Creates JournalEntryLine records for each line
   - All in single transaction
   - Rolls back if any error
   - Returns journal entry ID

2. **validateJournalEntry:**
   - Checks debits equal credits
   - Validates all amounts >= 0
   - Ensures at least 2 lines (DR and CR)
   - Returns errors if invalid

3. **getAccountByCode:**
   - Queries Account table by code
   - Caches results (5-minute TTL)
   - Returns account ID or null

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 1.2: Journal entry automation library

Create these files:

1. src/lib/accounting/types.ts
   - Export SourceType union type with 7 values: INVOICE, JOB_COMPLETION, PURCHASE_ORDER, PAYROLL_PERIOD, PAYMENT, ADJUSTMENT, OPENING_BALANCE
   - Export JournalEntryLine interface with: accountCode (string), accountId (string), debit (number), credit (number), description (optional string)
   - Export AutoJournalEntryParams interface with: sourceType (SourceType), sourceId (string), date (Date), description (string), lines (JournalEntryLine[])

2. src/lib/accounting/account-mapping.ts
   - Import query from @/lib/db
   - Export async function getAccountByCode(code: string): Promise<string | null>
     - Queries Account table for account with this code
     - Returns account.id or null
     - Add simple in-memory cache (Map) with 5-minute expiry
   - Export async function getAccountsByType(type: string): Promise<Account[]>
     - Queries accounts by accountType field
     - Returns array of accounts

3. src/lib/accounting/journal-entry-automation.ts
   - Import all types
   - Import query, withTransaction from @/lib/db
   - Export validateJournalEntry(lines: JournalEntryLine[]): returns { valid: boolean, errors: string[] }
     - Check debits sum equals credits sum
     - Check all amounts >= 0
     - Check at least 2 lines
     - Return validation result
   - Export async function createAutoJournalEntry(params: AutoJournalEntryParams): returns Promise<{ journalEntryId: string, balanced: boolean }>
     - Use withTransaction for atomicity
     - Validate entry first
     - Create JournalEntry record with sourceType, sourceId, autoGenerated=true
     - Create JournalEntryLine records for each line
     - Return journal entry ID
     - Throw error if validation fails or DB error
   - Add detailed error handling and logging

Use existing patterns from codebase. Follow TypeScript strict mode. Add JSDoc comments.
```

### ‚úÖ Testing Instructions

Create test file: `src/lib/accounting/__tests__/journal-entry-automation.test.ts`

```typescript
import { validateJournalEntry, createAutoJournalEntry } from '../journal-entry-automation'
import { getAccountByCode } from '../account-mapping'

describe('Journal Entry Automation', () => {
  test('validateJournalEntry - balanced entry', () => {
    const result = validateJournalEntry([
      { accountCode: '1000', accountId: 'acc-1', debit: 100, credit: 0 },
      { accountCode: '4000', accountId: 'acc-2', debit: 0, credit: 100 }
    ])
    expect(result.valid).toBe(true)
    expect(result.errors).toHaveLength(0)
  })

  test('validateJournalEntry - unbalanced entry', () => {
    const result = validateJournalEntry([
      { accountCode: '1000', accountId: 'acc-1', debit: 100, credit: 0 },
      { accountCode: '4000', accountId: 'acc-2', debit: 0, credit: 50 }
    ])
    expect(result.valid).toBe(false)
    expect(result.errors).toContain('Debits (100) do not equal credits (50)')
  })

  test('getAccountByCode - existing account', async () => {
    const accountId = await getAccountByCode('1000')
    expect(accountId).toBeTruthy()
  })

  test('createAutoJournalEntry - success', async () => {
    const result = await createAutoJournalEntry({
      sourceType: 'INVOICE',
      sourceId: 'inv-test-123',
      date: new Date(),
      description: 'Test invoice',
      lines: [
        { accountCode: '1100', accountId: await getAccountByCode('1100')!, debit: 1000, credit: 0 },
        { accountCode: '4000', accountId: await getAccountByCode('4000')!, debit: 0, credit: 1000 }
      ]
    })
    expect(result.journalEntryId).toBeTruthy()
    expect(result.balanced).toBe(true)

    // Cleanup
    await query('DELETE FROM "JournalEntry" WHERE id = $1', [result.journalEntryId])
  })
})
```

### üìã Audit Checklist

- [ ] All TypeScript types properly defined
- [ ] Transaction safety in createAutoJournalEntry
- [ ] Validation catches unbalanced entries
- [ ] Error handling comprehensive
- [ ] Account caching implemented
- [ ] JSDoc comments added
- [ ] Follows existing code patterns
- [ ] No security vulnerabilities

### ‚è±Ô∏è Estimated Time

- Implementation: 1.5 hours
- Testing: 30 minutes
- **Total: 2 hours**

---

## Task 1.3: Invoice ‚Üí Revenue Recognition

### üéØ Goal

Automatically create revenue journal entry when invoice is created or paid.

### üìÅ Files to Modify/Create

1. Modify: `src/app/api/invoices/route.ts` (POST endpoint)
2. Create: `src/lib/workflows/invoice-automation.ts`
3. Create: `src/app/api/invoices/[id]/record-payment/route.ts`

### üìù Detailed Specifications

**Workflow:**

```
Invoice Created (POST /api/invoices)
        ‚Üì
Generate Invoice Number
        ‚Üì
Save Invoice to DB
        ‚Üì
Create Revenue Recognition JE:
   DR: Accounts Receivable (1100)
   CR: Service Revenue (4000)
        ‚Üì
Link JE to Invoice
        ‚Üì
Send Notification
```

**Journal Entry for Invoice Creation:**

```typescript
// When invoice created with totalAmount = $1,500
{
  date: invoice.invoiceDate,
  description: `Invoice ${invoiceNumber} - ${customerName}`,
  sourceType: 'INVOICE',
  sourceId: invoiceId,
  autoGenerated: true,
  lines: [
    {
      accountCode: '1100', // Accounts Receivable
      debit: 1500,
      credit: 0
    },
    {
      accountCode: '4000', // Service Revenue
      debit: 0,
      credit: 1500
    }
  ]
}
```

**Payment Recording:**

```typescript
// When payment received for $1,500
{
  date: paymentDate,
  description: `Payment - Invoice ${invoiceNumber}`,
  sourceType: 'PAYMENT',
  sourceId: invoiceId,
  autoGenerated: true,
  lines: [
    {
      accountCode: '1000', // Cash
      debit: 1500,
      credit: 0
    },
    {
      accountCode: '1100', // Accounts Receivable
      debit: 0,
      credit: 1500
    }
  ]
}
```

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 1.3: Invoice revenue recognition automation

1. Create src/lib/workflows/invoice-automation.ts:
   - Import createAutoJournalEntry, getAccountByCode
   - Export async function createInvoiceRevenueEntry(invoiceId: string): Promise<string>
     - Fetch invoice with customer name
     - Get AR account (code 1100) and Revenue account (code 4000)
     - Create journal entry with DR: AR, CR: Revenue for invoice total
     - Update invoice.journalEntryId with returned JE ID
     - Return journal entry ID
     - Wrap in try/catch with logging

   - Export async function createPaymentEntry(invoiceId: string, paymentAmount: number, paymentDate: Date): Promise<string>
     - Similar to above but DR: Cash (1000), CR: AR (1100)
     - Update invoice.paidAmount, paymentJournalEntryId
     - Calculate and update paymentStatus
     - Return journal entry ID

2. Modify src/app/api/invoices/route.ts POST endpoint:
   - After invoice is created and saved to DB
   - Call createInvoiceRevenueEntry(invoice.id)
   - Add try/catch around JE creation (don't fail invoice creation if JE fails, just log error)
   - Return success

3. Create src/app/api/invoices/[id]/record-payment/route.ts:
   - POST endpoint
   - Request body: { amount: number, paymentDate: string, paymentMethod: string, reference?: string }
   - Verify authentication
   - Validate invoice exists
   - Call createPaymentEntry()
   - Return updated invoice with payment info

Add error handling, logging, and validation throughout. Follow existing API patterns.
```

### ‚úÖ Testing Instructions

**Manual Testing:**

```typescript
// 1. Create an invoice via API
POST /api/invoices
{
  "customerId": "cust-123",
  "jobId": "job-456",
  "invoiceDate": "2025-11-08",
  "dueDate": "2025-12-08",
  "items": [
    { "description": "Labor", "quantity": 8, "rate": 125, "amount": 1000 }
  ],
  "subtotal": 1000,
  "tax": 0,
  "total": 1000
}

// 2. Verify invoice has journalEntryId
GET /api/invoices/{id}
// Response should include journalEntryId

// 3. Check journal entry exists and is balanced
SELECT je.*, jel.*
FROM "JournalEntry" je
JOIN "JournalEntryLine" jel ON je.id = jel."journalEntryId"
WHERE je.id = '{journalEntryId}';

// Should see:
// - Line 1: Account 1100 (AR), DR: 1000, CR: 0
// - Line 2: Account 4000 (Revenue), DR: 0, CR: 1000

// 4. Record payment
POST /api/invoices/{id}/record-payment
{
  "amount": 1000,
  "paymentDate": "2025-11-08",
  "paymentMethod": "CHECK",
  "reference": "Check #1234"
}

// 5. Verify payment journal entry
// Should see new JE with DR: Cash, CR: AR

// 6. Verify invoice status updated
// paymentStatus should be 'PAID'
// paidAmount should be 1000
```

### üìã Audit Checklist

- [ ] Revenue entry created on invoice creation
- [ ] Payment entry created on payment recording
- [ ] All journal entries balanced
- [ ] Invoice.journalEntryId populated
- [ ] Invoice.paymentJournalEntryId populated
- [ ] PaymentStatus calculated correctly
- [ ] Error handling prevents invoice creation failure
- [ ] Logging captures all events
- [ ] API follows existing patterns

### ‚è±Ô∏è Estimated Time

- Implementation: 2 hours
- Testing: 1 hour
- **Total: 3 hours**

---

## Task 1.4: Job Completion ‚Üí COGS Recognition

### üéØ Goal

Automatically create COGS journal entry when job status changes to COMPLETED.

### üìÅ Files to Modify/Create

1. Modify: `src/app/api/jobs/[id]/route.ts` (PATCH endpoint)
2. Create: `src/lib/workflows/job-completion-automation.ts`

### üìù Detailed Specifications

**Workflow:**

```
Job Status Changed to COMPLETED
        ‚Üì
Calculate Final Job Costs (if not already done)
        ‚Üì
Get JobCost breakdown
        ‚Üì
Create COGS Journal Entry:
   DR: COGS (5000) = total job cost
   CR: Inventory (1300) = material cost
   CR: Wages Expense (5100) = labor cost
   CR: Equipment Expense (5200) = equipment cost
        ‚Üì
Update Job.cogsJournalEntryId
        ‚Üì
Generate Invoice Draft (optional)
```

**Journal Entry Example:**

```typescript
// Job completed with costs:
// Labor: $2,800
// Materials: $1,200
// Equipment: $500
// Total: $4,500

{
  date: job.completedDate,
  description: `Job ${jobNumber} - COGS Recognition`,
  sourceType: 'JOB_COMPLETION',
  sourceId: jobId,
  autoGenerated: true,
  lines: [
    {
      accountCode: '5000', // COGS
      debit: 4500,
      credit: 0
    },
    {
      accountCode: '1300', // Inventory
      debit: 0,
      credit: 1200
    },
    {
      accountCode: '5100', // Wages Expense
      debit: 0,
      credit: 2800
    },
    {
      accountCode: '5200', // Equipment Expense
      debit: 0,
      credit: 500
    }
  ]
}
```

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 1.4: Job completion COGS recognition

1. Create src/lib/workflows/job-completion-automation.ts:
   - Import createAutoJournalEntry, getAccountByCode
   - Import query from @/lib/db

   - Export async function createJobCOGSEntry(jobId: string): Promise<string>
     - Fetch job details (jobNumber, completedDate)
     - Calculate job costs (call calculate_job_costs function if needed)
     - Fetch JobCost record for this job
     - Get account IDs for: COGS (5000), Inventory (1300), Wages (5100), Equipment (5200)

     - Build journal entry lines:
       * DR: COGS for totalJobCost
       * CR: Inventory for totalMaterialCost (if > 0)
       * CR: Wages for totalLaborCost (if > 0)
       * CR: Equipment for totalEquipmentCost (if > 0)

     - Call createAutoJournalEntry()
     - Update Job.cogsJournalEntryId
     - Return journal entry ID
     - Add comprehensive error handling

2. Modify src/app/api/jobs/[id]/route.ts PATCH endpoint:
   - After job status is updated
   - Check if newStatus === 'COMPLETED' AND oldStatus !== 'COMPLETED'
   - If true, call createJobCOGSEntry(jobId)
   - Wrap in try/catch (don't fail job update if JE fails, just log error)
   - Continue with existing response

Add logging for audit trail. Handle edge cases (job with zero costs, etc.).
```

### ‚úÖ Testing Instructions

```typescript
// 1. Create a job with time entries and material usage
// (Use existing test data or create via API)

// 2. Mark job as completed
PATCH /api/jobs/{jobId}
{
  "status": "COMPLETED",
  "completedDate": "2025-11-08"
}

// 3. Verify job has cogsJournalEntryId
GET /api/jobs/{jobId}
// Should include cogsJournalEntryId

// 4. Check journal entry
SELECT je.*, jel.*,
       a.code as account_code,
       a.name as account_name
FROM "JournalEntry" je
JOIN "JournalEntryLine" jel ON je.id = jel."journalEntryId"
JOIN "Account" a ON jel."accountId" = a.id
WHERE je.id = '{cogsJournalEntryId}'
ORDER BY jel."lineNumber";

// Verify:
// - One DR line for COGS (sum of all costs)
// - CR lines for each cost type that exists
// - Total debits = total credits

// 5. Test edge case: Job with only labor costs
// 6. Test edge case: Job with zero costs (should handle gracefully)

// 7. Verify calculate_job_costs was called
SELECT * FROM "JobCost" WHERE "jobId" = '{jobId}';
// Should have recent lastCalculated timestamp
```

### üìã Audit Checklist

- [ ] COGS entry created when job completed
- [ ] Job costs calculated before JE creation
- [ ] All cost categories included (labor, materials, equipment)
- [ ] Zero-cost categories excluded from CR lines
- [ ] Journal entry balanced
- [ ] Job.cogsJournalEntryId updated
- [ ] Edge cases handled (zero costs, missing data)
- [ ] Status change doesn't fail if JE creation fails
- [ ] Audit trail logged

### ‚è±Ô∏è Estimated Time

- Implementation: 2 hours
- Testing: 1 hour
- **Total: 3 hours**

---

## Task 1.5: Unit Tests for Accounting Workflows

### üéØ Goal

Comprehensive test coverage for all accounting automation functions.

### üìÅ Files to Create

1. `src/lib/accounting/__tests__/journal-entry-automation.test.ts`
2. `src/lib/accounting/__tests__/account-mapping.test.ts`
3. `src/lib/workflows/__tests__/invoice-automation.test.ts`
4. `src/lib/workflows/__tests__/job-completion-automation.test.ts`

### üìù Test Coverage Requirements

**Minimum Coverage:**
- Functions: 80%
- Lines: 75%
- Branches: 70%

**Test Categories:**
1. **Happy Path** - Normal operations succeed
2. **Edge Cases** - Zero amounts, missing data, etc.
3. **Error Cases** - Invalid data, DB errors, etc.
4. **Transaction Safety** - Rollback on errors
5. **Validation** - Input validation works

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 1.5: Unit tests for accounting workflows

Create comprehensive test suites for:

1. src/lib/accounting/__tests__/journal-entry-automation.test.ts
   - Test validateJournalEntry with balanced/unbalanced entries
   - Test negative amounts rejected
   - Test minimum lines requirement
   - Test createAutoJournalEntry success
   - Test createAutoJournalEntry rollback on error
   - Test source tracking fields populated
   - Test auto-generated flag set correctly

2. src/lib/accounting/__tests__/account-mapping.test.ts
   - Test getAccountByCode finds existing accounts
   - Test getAccountByCode returns null for non-existent
   - Test caching works (second call doesn't hit DB)
   - Test cache expiry after 5 minutes
   - Test getAccountsByType returns correct accounts

3. src/lib/workflows/__tests__/invoice-automation.test.ts
   - Test createInvoiceRevenueEntry creates correct JE
   - Test AR account debited, Revenue credited
   - Test invoice.journalEntryId updated
   - Test createPaymentEntry creates correct JE
   - Test Cash debited, AR credited
   - Test payment status updates correctly
   - Test partial payment handling

4. src/lib/workflows/__tests__/job-completion-automation.test.ts
   - Test createJobCOGSEntry with all cost types
   - Test with only labor costs
   - Test with zero costs (should skip JE creation)
   - Test COGS account debited correctly
   - Test expense accounts credited correctly
   - Test job.cogsJournalEntryId updated

Use Jest framework. Mock database calls. Follow existing test patterns in codebase.
Add setup/teardown to create and clean test data. Use descriptive test names.
```

### ‚úÖ Running Tests

```bash
# Run all tests
npm test src/lib/accounting
npm test src/lib/workflows

# Run with coverage
npm test -- --coverage src/lib/accounting src/lib/workflows

# Run specific test file
npm test src/lib/accounting/__tests__/journal-entry-automation.test.ts

# Watch mode (during development)
npm test -- --watch
```

### üìã Audit Checklist

- [ ] All critical functions tested
- [ ] Edge cases covered
- [ ] Error cases handled
- [ ] Transaction rollback tested
- [ ] Mocks used appropriately
- [ ] Tests are deterministic (no flaky tests)
- [ ] Test data cleaned up after each test
- [ ] Coverage meets minimums (80/75/70)

### ‚è±Ô∏è Estimated Time

- Implementation: 2 hours
- **Total: 2 hours**

---

## Task 2.1: Vendor Invoice & AP Tracking

### üéØ Goal

Create database structures and functions for tracking accounts payable and vendor balances.

### üìÅ Files to Create

1. `migrations/phase1/002_vendor_invoice_table.sql`
2. `migrations/phase1/002_vendor_invoice_table_rollback.sql`
3. `migrations/phase1/003_vendor_balance_fields.sql`
4. `src/lib/accounting/vendor-management.ts`

### üìù Detailed Specifications

**VendorInvoice Table:**

```sql
CREATE TABLE "VendorInvoice" (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "vendorId" text NOT NULL REFERENCES "Vendor"(id),
  "purchaseOrderId" text REFERENCES "PurchaseOrder"(id),
  "invoiceNumber" varchar(100) NOT NULL,
  "invoiceDate" date NOT NULL,
  "dueDate" date NOT NULL,
  amount numeric(12,2) NOT NULL CHECK (amount >= 0),
  "paidAmount" numeric(12,2) DEFAULT 0 CHECK ("paidAmount" >= 0 AND "paidAmount" <= amount),
  "paymentStatus" varchar(20) NOT NULL DEFAULT 'UNPAID',
  "paidDate" timestamp,
  "paymentMethod" varchar(50),
  "checkNumber" varchar(50),
  "paymentReference" varchar(100),
  "journalEntryId" text REFERENCES "JournalEntry"(id),
  "paymentJournalEntryId" text REFERENCES "JournalEntry"(id),
  notes text,
  "createdAt" timestamp DEFAULT now(),
  "updatedAt" timestamp DEFAULT now(),
  "createdBy" text REFERENCES "User"(id),

  CONSTRAINT "VendorInvoice_status_check"
    CHECK ("paymentStatus" IN ('UNPAID', 'PARTIALLY_PAID', 'PAID', 'OVERDUE')),
  CONSTRAINT "VendorInvoice_unique_number"
    UNIQUE ("vendorId", "invoiceNumber")
);
```

**Vendor Balance Fields:**

```sql
ALTER TABLE "Vendor"
ADD COLUMN "currentBalance" numeric(12,2) DEFAULT 0,
ADD COLUMN "lastPurchaseDate" timestamp,
ADD COLUMN "lastPaymentDate" timestamp,
ADD COLUMN "paymentTerms" varchar(50) DEFAULT 'Net 30';
```

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 2.1: Vendor invoice and AP tracking

1. Create migrations/phase1/002_vendor_invoice_table.sql:
   - Create VendorInvoice table with all fields as specified
   - Add indexes on: vendorId, purchaseOrderId, paymentStatus, dueDate
   - Add unique index on (vendorId, invoiceNumber)
   - Create trigger function update_vendor_invoice_payment_status()
     * Auto-updates paymentStatus based on paidAmount vs amount
     * PAID if paidAmount >= amount
     * PARTIALLY_PAID if paidAmount > 0
     * OVERDUE if dueDate < CURRENT_DATE and unpaid
     * UNPAID otherwise
   - Create trigger on INSERT/UPDATE
   - Wrap in transaction

2. Create rollback: migrations/phase1/002_vendor_invoice_table_rollback.sql

3. Create migrations/phase1/003_vendor_balance_fields.sql:
   - Alter Vendor table to add currentBalance, lastPurchaseDate, lastPaymentDate, paymentTerms
   - Add index on currentBalance WHERE currentBalance > 0

4. Create src/lib/accounting/vendor-management.ts:
   - Export async function createVendorInvoice(params): creates vendor invoice record
   - Export async function recordVendorPayment(vendorInvoiceId, payment): records payment, updates balance
   - Export async function getVendorBalance(vendorId): returns current balance
   - Export async function getAPAging(): returns aging report data
   - All functions use transactions, have error handling

Use PostgreSQL best practices. Add helpful comments.
```

### ‚úÖ Testing Instructions

```sql
-- 1. Create test vendor invoice
INSERT INTO "VendorInvoice" (
  "vendorId", "invoiceNumber", "invoiceDate", "dueDate", amount
) VALUES (
  'test-vendor-1', 'INV-001', CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', 1000
);

-- 2. Verify status is UNPAID
SELECT "paymentStatus" FROM "VendorInvoice" WHERE "invoiceNumber" = 'INV-001';

-- 3. Record partial payment
UPDATE "VendorInvoice"
SET "paidAmount" = 500
WHERE "invoiceNumber" = 'INV-001';

-- 4. Verify status auto-updated to PARTIALLY_PAID
SELECT "paymentStatus" FROM "VendorInvoice" WHERE "invoiceNumber" = 'INV-001';

-- 5. Record full payment
UPDATE "VendorInvoice"
SET "paidAmount" = 1000
WHERE "invoiceNumber" = 'INV-001';

-- 6. Verify status is PAID
SELECT "paymentStatus" FROM "VendorInvoice" WHERE "invoiceNumber" = 'INV-001';

-- Cleanup
DELETE FROM "VendorInvoice" WHERE "invoiceNumber" = 'INV-001';
```

### üìã Audit Checklist

- [ ] VendorInvoice table created with all fields
- [ ] Payment status trigger works correctly
- [ ] Vendor balance fields added
- [ ] All indexes created
- [ ] Unique constraint on vendor + invoice number
- [ ] Management functions work
- [ ] Transaction safety maintained

### ‚è±Ô∏è Estimated Time

- Implementation: 1.5 hours
- Testing: 30 minutes
- **Total: 2 hours**

---

## Task 2.2: PO Receipt ‚Üí AP Workflow

### üéØ Goal

Automatically create AP journal entry and vendor invoice when PO is received.

### üìÅ Files to Modify/Create

1. Modify: `src/app/api/purchase-orders/[id]/receive/route.ts` (or create if doesn't exist)
2. Create: `src/lib/workflows/po-receipt-automation.ts`

### üìù Detailed Specifications

**Workflow:**

```
PO Marked as Received
        ‚Üì
Update Material Stock (existing logic)
        ‚Üì
Create AP Journal Entry:
   DR: Inventory (1300)
   CR: Accounts Payable (2000)
        ‚Üì
Create VendorInvoice Record
        ‚Üì
Update Vendor.currentBalance
        ‚Üì
Link JE to PO
        ‚Üì
Notify Accounting
```

**Journal Entry:**

```typescript
// PO received for $1,500 of materials
{
  date: new Date(),
  description: `PO ${poNumber} - ${vendorName}`,
  sourceType: 'PURCHASE_ORDER',
  sourceId: poId,
  autoGenerated: true,
  lines: [
    {
      accountCode: '1300', // Inventory
      debit: 1500,
      credit: 0
    },
    {
      accountCode: '2000', // Accounts Payable
      debit: 0,
      credit: 1500
    }
  ]
}
```

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 2.2: PO receipt to AP automation

1. Create src/lib/workflows/po-receipt-automation.ts:
   - Import createAutoJournalEntry, createVendorInvoice
   - Export async function processPOReceipt(poId: string): Promise<void>
     - Fetch PO with vendor details
     - Create AP journal entry (DR: Inventory, CR: AP)
     - Create VendorInvoice record
     - Update Vendor.currentBalance
     - Update PO with journalEntryId and receivedDate
     - All in single transaction
     - Comprehensive error handling

2. Create/Modify src/app/api/purchase-orders/[id]/receive/route.ts:
   - POST endpoint
   - Verify authentication (admin/purchasing only)
   - Validate PO exists and not already received
   - Call processPOReceipt(poId)
   - Update material stock (existing logic)
   - Return success response

Add notification to accounting team. Follow API patterns. Handle errors gracefully.
```

### ‚úÖ Testing Instructions

```typescript
// 1. Create test PO with items
POST /api/purchase-orders
{
  "vendorId": "vendor-123",
  "items": [
    { "materialId": "mat-1", "quantity": 10, "unitPrice": 50 }
  ],
  "subtotal": 500
}

// 2. Approve PO
POST /api/purchase-orders/{poId}/approve

// 3. Mark as received
POST /api/purchase-orders/{poId}/receive
{
  "receivedDate": "2025-11-08"
}

// 4. Verify journal entry created
SELECT * FROM "JournalEntry" WHERE "sourceId" = '{poId}';

// 5. Verify vendor invoice created
SELECT * FROM "VendorInvoice" WHERE "purchaseOrderId" = '{poId}';

// 6. Verify vendor balance increased
SELECT "currentBalance" FROM "Vendor" WHERE id = 'vendor-123';

// 7. Verify material stock updated
SELECT "inStock" FROM "Material" WHERE id = 'mat-1';
```

### üìã Audit Checklist

- [ ] AP entry created on PO receipt
- [ ] VendorInvoice record created
- [ ] Vendor balance updated
- [ ] PO.journalEntryId populated
- [ ] Material stock updated
- [ ] Transaction atomicity maintained
- [ ] Error handling prevents partial updates
- [ ] Accounting team notified

### ‚è±Ô∏è Estimated Time

- Implementation: 2 hours
- Testing: 1 hour
- **Total: 3 hours**

---

## Task 2.3: Time Approval ‚Üí Payroll Accrual

### üéØ Goal

Create payroll accrual journal entry when time entries are approved.

### üìÅ Files to Modify/Create

1. Modify: `src/app/api/time-entries/[id]/approve/route.ts`
2. Create: `src/lib/workflows/payroll-accrual-automation.ts`

### üìù Detailed Specifications

**Workflow:**

```
Time Entry Approved
        ‚Üì
Calculate Labor Cost (existing logic)
        ‚Üì
Update JobLaborCost (existing logic)
        ‚Üì
Create Payroll Accrual JE:
   DR: Wages Expense (5100)
   CR: Wages Payable (2100)
        ‚Üì
Link to future payroll period (if exists)
```

**Journal Entry:**

```typescript
// Time entry approved: 8 hours at $25/hr = $200
{
  date: timeEntry.date,
  description: `Payroll accrual - ${userName}`,
  sourceType: 'TIME_ENTRY',
  sourceId: timeEntryId,
  autoGenerated: true,
  lines: [
    {
      accountCode: '5100', // Wages Expense
      debit: 200,
      credit: 0
    },
    {
      accountCode: '2100', // Wages Payable
      debit: 0,
      credit: 200
    }
  ]
}
```

**Note:** Can be batched per payroll period for efficiency.

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 2.3: Time approval payroll accrual

1. Create src/lib/workflows/payroll-accrual-automation.ts:
   - Export async function createPayrollAccrualEntry(timeEntryId: string): Promise<string>
     - Fetch time entry with user pay rates
     - Calculate total cost (regular + OT + DT hours √ó rates)
     - Create journal entry (DR: Wages Expense, CR: Wages Payable)
     - Return journal entry ID

   - Export async function createBatchPayrollAccrual(timeEntryIds: string[]): Promise<string>
     - Creates single JE for multiple time entries (more efficient)
     - Sum all labor costs
     - Single DR/CR pair for the batch
     - Used when closing payroll periods

2. Modify src/app/api/time-entries/[id]/approve/route.ts:
   - After time entry approved and costs updated
   - Call createPayrollAccrualEntry(timeEntryId)
   - Optional: Batch if multiple entries approved simultaneously
   - Continue with response (don't fail approval if accrual fails)

Add error handling. Consider performance for batch approvals.
```

### ‚úÖ Testing Instructions

```typescript
// 1. Submit time entry
POST /api/time-entries
{
  "userId": "user-123",
  "jobId": "job-456",
  "date": "2025-11-08",
  "hours": 8,
  "regularHours": 8,
  "overtimeHours": 0
}

// 2. Approve time entry
POST /api/time-entries/{timeEntryId}/approve

// 3. Verify accrual entry created
SELECT je.*, u."regularRate"
FROM "JournalEntry" je
JOIN "TimeEntry" te ON je."sourceId" = te.id
JOIN "User" u ON te."userId" = u.id
WHERE je."sourceId" = '{timeEntryId}';

// Calculate expected amount: hours √ó rate
// Verify DR: Wages Expense = expected amount
// Verify CR: Wages Payable = expected amount

// 4. Verify JobLaborCost updated
SELECT * FROM "JobLaborCost" WHERE "timeEntryId" = '{timeEntryId}';
```

### üìã Audit Checklist

- [ ] Accrual entry created on approval
- [ ] Labor cost calculated correctly (regular + OT + DT)
- [ ] Wages Expense debited
- [ ] Wages Payable credited
- [ ] Entry balanced
- [ ] Time entry approval not blocked by accrual failure
- [ ] Batch function available for efficiency
- [ ] Performance acceptable for large batches

### ‚è±Ô∏è Estimated Time

- Implementation: 1.5 hours
- Testing: 30 minutes
- **Total: 2 hours**

---

## Task 2.4: Integration Tests & Audit Trail

### üéØ Goal

End-to-end testing of complete workflows and verification of audit trails.

### üìÅ Files to Create

1. `src/__tests__/integration/accounting-workflows.test.ts`
2. `src/__tests__/integration/ap-workflow.test.ts`
3. `src/lib/accounting/audit-trail.ts`

### üìù Test Scenarios

**Complete Workflow Tests:**

1. **Invoice-to-Payment Flow:**
   - Create invoice ‚Üí Verify revenue JE
   - Record payment ‚Üí Verify payment JE
   - Check AR balance cleared

2. **Job-to-COGS Flow:**
   - Create job with time & materials
   - Complete job ‚Üí Verify COGS JE
   - Check all expense accounts credited

3. **PO-to-Payment Flow:**
   - Create PO ‚Üí Approve ‚Üí Receive
   - Verify AP JE and vendor invoice
   - Record payment ‚Üí Verify payment clears AP

4. **Payroll Cycle:**
   - Create multiple time entries
   - Approve all ‚Üí Verify accruals
   - Check total wages payable

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 2.4: Integration tests and audit trail

1. Create src/__tests__/integration/accounting-workflows.test.ts:
   - Test complete invoice-to-payment workflow
   - Test job completion with all cost types
   - Test trial balance remains balanced after each workflow
   - Test source tracking works correctly
   - Use real database (test/staging)
   - Setup creates test data, teardown cleans up

2. Create src/__tests__/integration/ap-workflow.test.ts:
   - Test PO receipt creates AP entry
   - Test vendor payment clears invoice
   - Test AP aging calculations
   - Test vendor balance tracking

3. Create src/lib/accounting/audit-trail.ts:
   - Export function getAuditTrail(sourceType, sourceId): returns all JEs for a transaction
   - Export function verifyTrialBalance(date?): checks debits = credits
   - Export function findUnbalancedEntries(): returns JEs that don't balance
   - Export function getJournalEntriesByDateRange(start, end): for reporting

Add comprehensive assertions. Test error scenarios. Verify data consistency.
```

### ‚úÖ Testing Instructions

```bash
# Run integration tests
npm test src/__tests__/integration

# Run specific test
npm test accounting-workflows.test.ts

# Run with verbose output
npm test -- --verbose integration/

# Verify trial balance after all tests
npm test -- --testNamePattern="trial balance"
```

**Manual Verification:**

```sql
-- 1. Check all auto-generated entries are balanced
SELECT je.id, je.description,
       SUM(jel.debit) as total_debit,
       SUM(jel.credit) as total_credit,
       SUM(jel.debit) - SUM(jel.credit) as difference
FROM "JournalEntry" je
JOIN "JournalEntryLine" jel ON je.id = jel."journalEntryId"
WHERE je."autoGenerated" = true
GROUP BY je.id, je.description
HAVING SUM(jel.debit) != SUM(jel.credit);

-- Should return 0 rows

-- 2. Verify all sources have entries
SELECT "sourceType", COUNT(*) as entry_count
FROM "JournalEntry"
WHERE "autoGenerated" = true
GROUP BY "sourceType";

-- 3. Check orphaned entries (source deleted but JE remains)
SELECT je.*
FROM "JournalEntry" je
LEFT JOIN "Invoice" i ON je."sourceType" = 'INVOICE' AND je."sourceId" = i.id
LEFT JOIN "Job" j ON je."sourceType" = 'JOB_COMPLETION' AND je."sourceId" = j.id
WHERE je."autoGenerated" = true
AND je."sourceType" IN ('INVOICE', 'JOB_COMPLETION')
AND i.id IS NULL
AND j.id IS NULL;

-- Should return 0 rows (or handle orphans appropriately)
```

### üìã Audit Checklist

- [ ] All workflows tested end-to-end
- [ ] Trial balance verified after each test
- [ ] Source tracking works for all entry types
- [ ] Audit trail functions work
- [ ] Error scenarios tested
- [ ] Data cleanup after tests
- [ ] No unbalanced entries in database
- [ ] Performance acceptable

### ‚è±Ô∏è Estimated Time

- Implementation: 2 hours
- Testing: 1 hour
- **Total: 3 hours**

---

## Task 2.5: Production Deployment & Documentation

### üéØ Goal

Safe deployment to production and comprehensive documentation for users.

### üìÅ Files to Create

1. `docs/PHASE_1_DEPLOYMENT_GUIDE.md`
2. `docs/PHASE_1_USER_GUIDE.md`
3. `docs/PHASE_1_ROLLBACK_PLAN.md`
4. `scripts/deploy-phase1.sh`

### üìù Deployment Checklist

**Pre-Deployment:**
- [ ] All tests passing on staging
- [ ] Trial balance verified on staging
- [ ] Accounting team reviewed and approved
- [ ] Full database backup created
- [ ] Rollback plan documented and tested
- [ ] Monitoring alerts configured

**Deployment Steps:**
1. Maintenance window notification
2. Final backup
3. Run migrations on production
4. Deploy code to production (via Git push)
5. Verify migrations successful
6. Smoke test key workflows
7. Monitor for errors (24 hours)

**Post-Deployment:**
- [ ] Create test invoice in production
- [ ] Verify journal entry created
- [ ] Complete test job in production
- [ ] Verify COGS entry created
- [ ] Receive test PO
- [ ] Verify AP entry created
- [ ] Approve test time entry
- [ ] Run trial balance report
- [ ] Announce to team

### üíª Cursor Composer Prompt

```
Create Phase 1 Task 2.5: Production deployment documentation

1. Create docs/PHASE_1_DEPLOYMENT_GUIDE.md:
   - Pre-deployment checklist
   - Step-by-step deployment instructions
   - Verification procedures
   - Post-deployment monitoring
   - Contact information for issues

2. Create docs/PHASE_1_USER_GUIDE.md:
   - Overview of new automation features
   - What changed for users
   - How to verify journal entries created
   - How to view audit trail
   - FAQ section
   - Screenshots if helpful

3. Create docs/PHASE_1_ROLLBACK_PLAN.md:
   - When to rollback (criteria)
   - Step-by-step rollback procedures
   - How to reverse migrations
   - Data cleanup if needed
   - Testing after rollback

4. Create scripts/deploy-phase1.sh:
   - Bash script to automate deployment
   - Creates backup
   - Runs migrations
   - Verifies success
   - Outputs deployment log

Make documentation clear and non-technical where possible. Add troubleshooting section.
```

### ‚úÖ Deployment Testing

**Staging Deployment Test:**

```bash
# 1. Run deployment script on staging
./scripts/deploy-phase1.sh staging

# 2. Verify migrations
psql $STAGING_DATABASE_URL -c "
  SELECT * FROM pg_tables
  WHERE tablename = 'VendorInvoice';
"

# 3. Run smoke tests
npm test -- --testNamePattern="smoke"

# 4. Manual verification
# - Create invoice
# - Complete job
# - Receive PO
# - Check all JEs created

# 5. Review logs
tail -f logs/deployment.log
```

**Production Deployment (when ready):**

```bash
# 1. Announce maintenance window
# 2. Create backup
pg_dump $DATABASE_URL > backup_production_phase1.sql

# 3. Deploy
./scripts/deploy-phase1.sh production

# 4. Verify and monitor
# 5. Announce completion
```

### üìã Audit Checklist

- [ ] Deployment guide complete and tested
- [ ] User guide clear and helpful
- [ ] Rollback plan tested on staging
- [ ] Deployment script works
- [ ] Monitoring configured
- [ ] Accounting team trained
- [ ] Success criteria met
- [ ] Production stable for 48 hours

### ‚è±Ô∏è Estimated Time

- Documentation: 1.5 hours
- Deployment: 30 minutes
- Verification: 30 minutes
- **Total: 2.5 hours**

---

## üìä Phase 1 Summary

### Total Estimated Time

| Task | Implementation | Testing | Total |
|------|----------------|---------|-------|
| 1.1 Database Migrations | 20 min | 10 min | 30 min |
| 1.2 Automation Library | 1.5 hrs | 30 min | 2 hrs |
| 1.3 Invoice Automation | 2 hrs | 1 hr | 3 hrs |
| 1.4 Job COGS Automation | 2 hrs | 1 hr | 3 hrs |
| 1.5 Unit Tests | 2 hrs | - | 2 hrs |
| 2.1 Vendor AP Tracking | 1.5 hrs | 30 min | 2 hrs |
| 2.2 PO Receipt Automation | 2 hrs | 1 hr | 3 hrs |
| 2.3 Payroll Accrual | 1.5 hrs | 30 min | 2 hrs |
| 2.4 Integration Tests | 2 hrs | 1 hr | 3 hrs |
| 2.5 Deployment & Docs | 1.5 hrs | 1 hr | 2.5 hrs |
| **TOTAL** | **17 hrs** | **6.5 hrs** | **23.5 hrs** |

**Add buffer for unforeseen issues:** +20% = **~28 hours total**

**Calendar time:** 2-3 weeks at 15-20 hours/week

---

## üéØ Success Criteria

**Phase 1 Complete When:**

‚úÖ **Automation Working:**
- [ ] Every invoice creates revenue journal entry
- [ ] Every completed job creates COGS journal entry
- [ ] Every received PO creates AP entry
- [ ] Every approved time entry creates accrual

‚úÖ **Data Integrity:**
- [ ] All journal entries balanced (debits = credits)
- [ ] Trial balance accurate
- [ ] Source tracking working
- [ ] No orphaned records

‚úÖ **Testing:**
- [ ] All unit tests passing (80%+ coverage)
- [ ] All integration tests passing
- [ ] Manual smoke tests successful
- [ ] No errors in production after 48 hours

‚úÖ **Documentation:**
- [ ] User guide complete
- [ ] Deployment guide tested
- [ ] Rollback plan validated
- [ ] Accounting team trained

‚úÖ **Business Impact:**
- [ ] Zero manual journal entries needed
- [ ] Accounting team satisfied
- [ ] Time savings achieved (~10-15 hrs/week)
- [ ] Financial reports accurate

---

## üö® Troubleshooting Guide

### Common Issues

**Issue: Migration fails**
- Check PostgreSQL version compatibility
- Verify no conflicting column names
- Review migration logs for specific error
- Use rollback script if needed

**Issue: Journal entry unbalanced**
- Check rounding errors in calculations
- Verify all amounts are >= 0
- Review line item generation logic
- Check validation function

**Issue: Tests failing**
- Ensure test database is clean
- Check for leftover test data
- Verify mocks are properly configured
- Review test setup/teardown

**Issue: Performance slow**
- Check if indexes were created
- Review query execution plans
- Consider batching operations
- Check for N+1 query problems

**Issue: Integration broken after deploy**
- Review deployment logs
- Check environment variables
- Verify database migrations completed
- Test rollback procedure

---

## üìû Support & Resources

**During Implementation:**
- Share code with Claude for audit after each task
- Ask questions in daily standup
- Document blockers immediately
- Keep stakeholders updated weekly

**After Deployment:**
- Monitor error logs closely (first 48 hours)
- Accounting team has direct line for issues
- Claude available for urgent fixes
- Weekly check-ins for first month

**Documentation References:**
- System Architecture: `docs/SYSTEM_ARCHITECTURE.md`
- Integration Gaps: `docs/INTEGRATION_GAPS_ANALYSIS.md`
- Full Roadmap: `docs/ERP_IMPROVEMENT_ROADMAP.md`
- Database Changes: `docs/DATABASE_IMPROVEMENTS.md`

---

## ‚úÖ Ready to Start

**Next Steps:**

1. **Review this guide** - Make sure you understand each task
2. **Set up staging** - Ensure environment is ready
3. **Start with Task 1.1** - Database migrations
4. **Daily rhythm** - Implement ‚Üí Audit ‚Üí Test ‚Üí Next
5. **Stay in touch** - Share progress, ask questions

**First Composer Prompt:**

Copy and paste the **Task 1.1 Cursor Composer Prompt** into Composer to begin!

---

**Good luck! Let's build something great. üöÄ**
